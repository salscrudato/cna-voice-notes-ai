================================================================================
FILE: src/App.tsx
================================================================================
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import { lazy, Suspense } from 'react'
import { ErrorBoundary } from './components/ErrorBoundary'
import { SkipToContent } from './components/SkipToContent'
import { LayoutShell } from './components/LayoutShell'
import { LandingPage } from './pages/LandingPage'

// Lazy load pages for better code splitting
const MainChatPage = lazy(() => import('./pages/MainChatPage').then(m => ({ default: m.MainChatPage })))
const ChatHistoryPage = lazy(() => import('./pages/ChatHistoryPage').then(m => ({ default: m.ChatHistoryPage })))
const AudioUploadPage = lazy(() => import('./pages/AudioUploadPage').then(m => ({ default: m.AudioUploadPage })))

// Loading fallback component
const PageLoader = () => (
  <div className="h-screen flex items-center justify-center bg-white">
    <div className="text-center">
      <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4" />
      <p className="text-slate-600 font-medium">Loading...</p>
    </div>
  </div>
)

function App() {
  return (
    <LayoutShell>
      <ErrorBoundary>
        <Router>
          <SkipToContent />
          <Suspense fallback={<PageLoader />}>
            <Routes>
              <Route path="/" element={<LandingPage />} />
              <Route path="/chat" element={<MainChatPage />} />
              <Route path="/history" element={<ChatHistoryPage />} />
              <Route path="/upload" element={<AudioUploadPage />} />
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </Suspense>
        </Router>
      </ErrorBoundary>
    </LayoutShell>
  )
}

export default App


================================================================================
FILE: src/components/ApiErrorBanner.tsx
================================================================================
import React, { memo } from 'react'
import { FiAlertCircle, FiX } from 'react-icons/fi'

interface ApiErrorBannerProps {
  error: string | undefined
  onDismiss?: () => void
}

const ApiErrorBannerComponent: React.FC<ApiErrorBannerProps> = ({ error, onDismiss }) => {
  if (!error) return null

  return (
    <div className="border-b border-red-300 bg-gradient-to-r from-red-50 to-red-100/50 px-6 py-4 shadow-md animate-slide-in-down backdrop-blur-sm" role="alert" aria-live="assertive" aria-atomic="true">
      <div className="flex items-start gap-3 max-w-4xl mx-auto">
        <FiAlertCircle className="text-red-600 flex-shrink-0 mt-0.5 animate-pulse" size={22} aria-hidden="true" />
        <div className="flex-1 min-w-0">
          <p className="text-sm font-bold text-red-900">Error</p>
          <p className="text-sm text-red-800 mt-1 break-words font-medium">{error}</p>
        </div>
        {onDismiss && (
          <button
            onClick={onDismiss}
            className="flex-shrink-0 p-1.5 hover:bg-red-200 rounded-lg transition-all duration-200 text-red-600 hover:text-red-700 hover:scale-110 active:scale-95 focus-visible-ring"
            aria-label="Dismiss error"
            type="button"
          >
            <FiX size={20} />
          </button>
        )}
      </div>
    </div>
  )
}

export const ApiErrorBanner = memo(ApiErrorBannerComponent)



================================================================================
FILE: src/components/ChatHeader.tsx
================================================================================
import React, { memo } from 'react'
import { FiMenu, FiX, FiMessageCircle, FiMic, FiFilter } from 'react-icons/fi'

interface ChatHeaderProps {
  sidebarOpen: boolean
  onToggleSidebar: () => void
  currentConversationTitle?: string
  linkedVoiceNoteName?: string
  onOpenFilters?: () => void
}

const ChatHeaderComponent: React.FC<ChatHeaderProps> = ({
  sidebarOpen,
  onToggleSidebar,
  currentConversationTitle,
  linkedVoiceNoteName,
  onOpenFilters,
}) => {
  return (
    <div className="border-b border-slate-200 px-3 sm:px-6 py-3.5 sm:py-4 flex flex-col gap-2 bg-gradient-to-r from-white to-slate-50 shadow-sm hover:shadow-md transition-shadow duration-200">
      {/* Header row with menu and title */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <button
            onClick={onToggleSidebar}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all duration-200 text-slate-600 hover:text-slate-900 hover:scale-110 active:scale-95 focus-visible-ring"
            aria-label={sidebarOpen ? 'Close sidebar' : 'Open sidebar'}
            aria-expanded={sidebarOpen}
            aria-controls="chat-sidebar"
            type="button"
          >
            {sidebarOpen ? <FiX size={20} aria-hidden="true" /> : <FiMenu size={20} aria-hidden="true" />}
          </button>

          {/* Mobile filters button */}
          {onOpenFilters && (
            <button
              onClick={onOpenFilters}
              className="p-2 hover:bg-slate-100 rounded-lg transition-all duration-200 text-slate-600 hover:text-slate-900 hover:scale-110 active:scale-95 focus-visible-ring md:hidden"
              aria-label="Open filters"
              type="button"
            >
              <FiFilter size={20} aria-hidden="true" />
            </button>
          )}
        </div>

        {/* Breadcrumb Navigation with improved visual hierarchy */}
        <div className="flex-1 flex items-center gap-2 px-4">
          <div className="flex items-center gap-2">
            <FiMessageCircle size={20} className="text-blue-600 flex-shrink-0" aria-hidden="true" />
            <span className="hidden sm:inline text-sm font-bold text-slate-900">Chat</span>
          </div>
          {currentConversationTitle && (
            <>
              <span className="text-slate-300 hidden sm:inline">/</span>
              <span className="text-xs sm:text-sm font-semibold text-slate-700 truncate hidden sm:inline max-w-xs" title={currentConversationTitle}>
                {currentConversationTitle}
              </span>
            </>
          )}
        </div>

        {/* Status indicator */}
        <div className="flex items-center gap-2 text-xs text-slate-500">
          <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" aria-hidden="true" />
          <span className="hidden sm:inline">Connected</span>
        </div>
      </div>

      {/* Voice note context banner */}
      {linkedVoiceNoteName && (
        <div className="flex items-center gap-2 px-2 py-1.5 bg-blue-50 border border-blue-200 rounded-md">
          <FiMic size={16} className="text-blue-600 flex-shrink-0" aria-hidden="true" />
          <span className="text-xs text-blue-700 font-medium truncate">
            Voice note: <span className="font-semibold">{linkedVoiceNoteName}</span>
          </span>
        </div>
      )}
    </div>
  )
}

export const ChatHeader = memo(ChatHeaderComponent)



================================================================================
FILE: src/components/ChatInput.tsx
================================================================================
import React, { memo, useCallback } from 'react'
import { FiArrowUp } from 'react-icons/fi'
import { UI } from '../constants'

interface ChatInputProps {
  value: string
  onChange: (value: string) => void
  onKeyPress: (e: React.KeyboardEvent) => void
  onSend: () => void
  isLoading: boolean
}

const ChatInputComponent: React.FC<ChatInputProps> = ({
  value,
  onChange,
  onKeyPress,
  onSend,
  isLoading,
}) => {
  const isDisabled = isLoading || !value.trim()
  const charCount = value.length
  const maxChars = UI.MAX_MESSAGE_LENGTH

  const handleClick = useCallback(() => {
    if (!isDisabled) {
      onSend()
    }
  }, [isDisabled, onSend])

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    // Ctrl/Cmd + Enter to send
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault()
      if (!isDisabled) {
        onSend()
      }
    }
  }, [isDisabled, onSend])

  return (
    <div className="border-t border-slate-200 p-4 sm:p-6 bg-gradient-to-b from-white to-slate-50">
      <div className="flex gap-3 sm:gap-4 max-w-4xl mx-auto items-end">
        <div className="flex-1 relative">
          <textarea
            value={value}
            onChange={(e) => {
              if (e.target.value.length <= maxChars) {
                onChange(e.target.value)
              }
            }}
            onKeyPress={onKeyPress}
            onKeyDown={handleKeyDown}
            placeholder="Ask me anything..."
            rows={UI.MESSAGE_INPUT_ROWS}
            disabled={isLoading}
            maxLength={maxChars}
            className="w-full px-5 py-3.5 bg-white border border-slate-300 rounded-2xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none text-sm text-slate-900 placeholder-slate-500 transition-all duration-200 hover:border-slate-400 disabled:opacity-60 disabled:cursor-not-allowed shadow-md hover:shadow-lg focus:shadow-xl"
            style={{ maxHeight: `${UI.MESSAGE_INPUT_MAX_HEIGHT}px` }}
            aria-label="Message input"
            aria-describedby="send-button char-count"
            aria-busy={isLoading}
          />
        </div>
        <button
          id="send-button"
          onClick={handleClick}
          disabled={isDisabled}
          className={`w-12 h-12 rounded-2xl flex items-center justify-center transition-all duration-200 flex-shrink-0 font-medium touch-target ${
            isDisabled
              ? 'bg-slate-200 text-slate-400 cursor-not-allowed'
              : 'bg-gradient-to-br from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 text-white shadow-lg hover:shadow-xl hover:scale-110 active:scale-95'
          }`}
          aria-label={isLoading ? 'Sending message' : 'Send message'}
          aria-busy={isLoading}
          type="button"
        >
          {isLoading ? (
            <div className="animate-spin">
              <FiArrowUp size={20} aria-hidden="true" />
            </div>
          ) : (
            <FiArrowUp size={20} aria-hidden="true" />
          )}
        </button>
      </div>
      {value.length > 0 && (
        <div className="text-xs mt-3 max-w-4xl mx-auto flex items-center justify-end gap-3">
          <div className="w-full max-w-xs bg-slate-200 rounded-full h-2 overflow-hidden">
            <div
              className={`h-full transition-all duration-200 ${
                charCount > maxChars * 0.9
                  ? 'bg-red-500'
                  : charCount > maxChars * 0.75
                    ? 'bg-amber-500'
                    : 'bg-blue-500'
              }`}
              style={{ width: `${Math.min((charCount / maxChars) * 100, 100)}%` }}
              aria-hidden="true"
            />
          </div>
          <div id="char-count" className={`font-semibold whitespace-nowrap text-xs ${
            charCount > maxChars * 0.9
              ? 'text-red-600'
              : charCount > maxChars * 0.75
                ? 'text-amber-600'
                : 'text-slate-500'
          }`}>
            {charCount} / {maxChars}
          </div>
        </div>
      )}
    </div>
  )
}

export const ChatInput = memo(ChatInputComponent)



================================================================================
FILE: src/components/ChatMessages.tsx
================================================================================
import React, { useRef, useEffect, memo, useState, useCallback } from 'react'
import { FiCopy, FiCheck } from 'react-icons/fi'
import { MessageRenderer } from './MessageRenderer'
import { UI } from '../constants'
import { formatTime } from '../utils/formatting'
import type { ChatMessage } from '../types'

interface ChatMessagesProps {
  messages: ChatMessage[]
  isLoading: boolean
}

interface MessageItemProps {
  message: ChatMessage
  isCopied: boolean
  onCopy: (messageId: string, content: string) => void
}

// Memoized message item component for performance optimization
const MessageItem = memo<MessageItemProps>(({ message: msg, isCopied, onCopy }) => (
  <div
    className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'} animate-slide-in-${msg.role === 'user' ? 'right' : 'left'} group`}
    role="article"
    aria-label={`${msg.role === 'user' ? 'Your message' : 'Assistant message'}`}
  >
    <div className="flex flex-col gap-1.5 max-w-2xl">
      <div className="flex items-end gap-2">
        <div
          className={`px-5 py-3.5 rounded-2xl transition-all duration-200 ${
            msg.role === 'user'
              ? 'bg-gradient-to-br from-blue-600 to-blue-700 text-white rounded-br-none shadow-lg hover:shadow-xl hover:from-blue-500 hover:to-blue-600'
              : 'bg-slate-100 text-slate-900 rounded-bl-none shadow-sm border border-slate-200 hover:shadow-md hover:border-slate-300 hover:bg-slate-50'
          }`}
        >
          {msg.role === 'user' ? (
            <p className="text-sm leading-relaxed whitespace-pre-wrap break-words font-medium">{msg.content}</p>
          ) : (
            <MessageRenderer content={msg.content} />
          )}
        </div>
        {msg.role === 'assistant' && (
          <button
            onClick={() => onCopy(msg.id, msg.content)}
            className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 p-2 hover:bg-slate-200 rounded-lg text-slate-500 hover:text-slate-700 flex-shrink-0 hover:scale-110 active:scale-95"
            title="Copy message"
            aria-label="Copy message"
            type="button"
          >
            {isCopied ? (
              <FiCheck size={18} className="text-green-600" />
            ) : (
              <FiCopy size={18} />
            )}
          </button>
        )}
      </div>
      {/* Message Timestamp - always visible on hover, always visible on mobile */}
      <div className={`text-xs transition-opacity duration-200 ${
        msg.role === 'user' ? 'text-right pr-1' : 'text-left pl-1'
      } ${msg.role === 'user' ? 'text-blue-200' : 'text-slate-500'} sm:opacity-0 sm:group-hover:opacity-100`}>
        {msg.createdAt ? formatTime(msg.createdAt) : ''}
      </div>
    </div>
  </div>
))

const ChatMessagesComponent: React.FC<ChatMessagesProps> = ({ messages, isLoading }) => {
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const [copiedId, setCopiedId] = useState<string | null>(null)

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: UI.MESSAGE_SCROLL_BEHAVIOR })
  }, [messages, isLoading])

  const handleCopyMessage = useCallback((messageId: string, content: string) => {
    navigator.clipboard.writeText(content).then(() => {
      setCopiedId(messageId)
      setTimeout(() => setCopiedId(null), UI.COPY_FEEDBACK_DURATION)
    }).catch((error) => {
      console.error('Failed to copy message:', error)
    })
  }, [])

  return (
    <main className="flex-1 overflow-y-auto p-4 sm:p-8 space-y-5 sm:space-y-6 bg-gradient-to-b from-white to-slate-50" role="main" aria-label="Chat messages">
      {messages.length === 0 && !isLoading && (
        <div className="flex items-center justify-center h-full">
          <div className="text-center animate-fade-in max-w-md px-4">
            <div className="mb-8">
              <div className="w-28 h-28 mx-auto bg-gradient-to-br from-blue-500 via-cyan-500 to-blue-600 rounded-3xl flex items-center justify-center shadow-2xl hover:shadow-2xl transition-all duration-300 hover:scale-110 animate-pulse-soft" aria-hidden="true">
                <svg className="w-14 h-14 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                </svg>
              </div>
            </div>
            <h2 className="text-4xl sm:text-5xl font-bold text-slate-900 mb-4">Welcome to Marlamade</h2>
            <p className="text-slate-600 mb-6 text-lg sm:text-xl font-semibold">Start a conversation to begin</p>
            <p className="text-slate-500 text-base sm:text-lg leading-relaxed">Ask questions about your underwriting conversations and voice notes to get AI-powered insights instantly</p>
            <div className="mt-8 pt-8 border-t border-slate-200">
              <p className="text-xs sm:text-sm text-slate-500 font-medium">ðŸ’¡ Tip: Use the upload feature to add voice notes for analysis</p>
            </div>
          </div>
        </div>
      )}

      {messages.map((msg) => (
        <MessageItem
          key={msg.id}
          message={msg}
          isCopied={copiedId === msg.id}
          onCopy={handleCopyMessage}
        />
      ))}

      {isLoading && (
        <div className="flex justify-start animate-slide-in-left">
          <div className="bg-slate-100 text-slate-900 px-5 py-3.5 rounded-2xl rounded-bl-none shadow-md border border-slate-200">
            <div className="flex items-center gap-3">
              <div className="flex gap-1.5 items-center h-5">
                <div className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot" style={{ animationDelay: '0s' }} aria-hidden="true" />
                <div className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot" style={{ animationDelay: '0.15s' }} aria-hidden="true" />
                <div className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot" style={{ animationDelay: '0.3s' }} aria-hidden="true" />
              </div>
              <span className="text-sm font-semibold text-slate-700 tracking-wide">
                Thinking<span className="inline-block animate-thinking-dots w-3 text-left">.</span>
              </span>
            </div>
          </div>
        </div>
      )}

      <div ref={messagesEndRef} />
    </main>
  )
}

export const ChatMessages = memo(ChatMessagesComponent)



================================================================================
FILE: src/components/ChatSidebar.tsx
================================================================================
import React, { useMemo, memo, useState } from 'react'
import { useNavigate, useLocation } from 'react-router-dom'
import type { Conversation } from '../types'
import { FiPlus, FiClock, FiUploadCloud, FiHome, FiSearch, FiX } from 'react-icons/fi'
import { ConversationItem } from './ConversationItem'
import { getDateGroupLabel } from '../utils/dates'

interface ChatSidebarProps {
  isOpen: boolean
  conversations: Conversation[]
  currentConversationId: string | null
  onNewConversation: () => void
  onSelectConversation: (id: string) => void
  onDeleteConversation: (id: string) => void
  onRenameConversation: (id: string, newTitle: string) => void
}

const ChatSidebarComponent: React.FC<ChatSidebarProps> = ({
  isOpen,
  conversations,
  currentConversationId,
  onNewConversation,
  onSelectConversation,
  onDeleteConversation,
  onRenameConversation,
}) => {
  const navigate = useNavigate()
  const location = useLocation()
  const [searchQuery, setSearchQuery] = useState('')

  const isOnPage = (path: string) => location.pathname === path

  // Group conversations by date
  const groupedConversations = useMemo(() => {
    const filtered = conversations.filter(conv =>
      conv.title.toLowerCase().includes(searchQuery.toLowerCase())
    )

    const groups: Record<string, Conversation[]> = {}

    filtered.forEach(conv => {
      const groupKey = getDateGroupLabel(conv.createdAt)

      if (!groups[groupKey]) groups[groupKey] = []
      groups[groupKey].push(conv)
    })

    return groups
  }, [conversations, searchQuery])

  const conversationsList = useMemo(
    () =>
      Object.entries(groupedConversations).map(([groupName, convs]) => (
        <div key={groupName}>
          <div className="px-3 py-2 text-xs font-semibold text-slate-400 uppercase tracking-wider">
            {groupName}
          </div>
          <div className="space-y-1">
            {convs.map((conv) => (
              <ConversationItem
                key={conv.id}
                conversation={conv}
                isActive={currentConversationId === conv.id}
                onSelect={onSelectConversation}
                onDelete={onDeleteConversation}
                onRename={onRenameConversation}
              />
            ))}
          </div>
        </div>
      )),
    [groupedConversations, currentConversationId, onSelectConversation, onDeleteConversation, onRenameConversation]
  )

  return (
    <nav
      id="chat-sidebar"
      className={`${
        isOpen ? 'w-64' : 'w-0'
      } bg-white text-slate-900 transition-all duration-300 flex flex-col overflow-hidden shadow-lg border-r border-slate-200 fixed sm:relative h-screen sm:h-auto z-40 sm:z-auto`}
      aria-label="Chat history sidebar"
    >
      {/* Logo & Branding */}
      <div className="p-4 border-b border-slate-200 bg-gradient-to-b from-white to-slate-50">
        <div className="flex items-center gap-2 mb-5 group cursor-pointer hover:scale-105 transition-transform duration-300">
          <div className="w-9 h-9 bg-gradient-to-br from-blue-600 via-cyan-500 to-blue-700 rounded-xl flex items-center justify-center shadow-lg group-hover:shadow-xl group-hover:scale-110 transition-all duration-300">
            <span className="text-white font-bold text-xs">CNA</span>
          </div>
          <span className="font-bold text-sm text-slate-900 group-hover:text-blue-600 transition-colors">Marlamade</span>
        </div>
        <button
          onClick={onNewConversation}
          className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 text-white rounded-xl transition-all duration-200 font-semibold text-sm shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 focus-visible-ring"
          aria-label="Start a new chat conversation"
        >
          <FiPlus size={18} aria-hidden="true" />
          New Chat
        </button>
      </div>

      {/* Search Bar */}
      <div className="px-3 py-4 border-b border-slate-200">
        <div className="relative">
          <FiSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" size={16} aria-hidden="true" />
          <input
            type="text"
            placeholder="Search chats..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-9 pr-8 py-2.5 bg-slate-50 border border-slate-300 rounded-lg text-xs text-slate-900 placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200 hover:border-slate-400"
            aria-label="Search conversations"
          />
          {searchQuery && (
            <button
              onClick={() => setSearchQuery('')}
              className="absolute right-2 top-1/2 -translate-y-1/2 p-1 hover:bg-slate-200 rounded transition-colors text-slate-500 hover:text-slate-700"
              aria-label="Clear search"
              type="button"
            >
              <FiX size={16} />
            </button>
          )}
        </div>
      </div>

      {/* Chat History */}
      <div className="flex-1 overflow-y-auto p-2 space-y-1">
        {conversations.length === 0 ? (
          <p className="text-slate-500 text-xs p-3 text-center">No conversations yet</p>
        ) : Object.keys(groupedConversations).length === 0 ? (
          <p className="text-slate-500 text-xs p-3 text-center">No conversations found</p>
        ) : (
          conversationsList
        )}
      </div>

      {/* Navigation with improved visual indicators */}
      <div className="border-t border-slate-200 p-3 space-y-2 bg-gradient-to-b from-white to-slate-50">
        <button
          onClick={() => navigate('/history')}
          className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 text-sm group hover:scale-105 active:scale-95 focus-visible-ring ${
            isOnPage('/history')
              ? 'bg-gradient-to-r from-blue-50 to-blue-100 text-blue-700 font-semibold shadow-md border border-blue-300'
              : 'text-slate-600 hover:bg-slate-100 hover:text-slate-900'
          }`}
          aria-label="View conversation history"
          aria-current={isOnPage('/history') ? 'page' : undefined}
        >
          <FiClock size={16} className="group-hover:scale-110 transition-transform flex-shrink-0" aria-hidden="true" />
          <span>History</span>
          {isOnPage('/history') && (
            <div className="ml-auto flex items-center gap-2">
              <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse" aria-hidden="true" />
              <div className="w-1.5 h-1.5 bg-blue-600 rounded-full" aria-hidden="true" />
            </div>
          )}
        </button>
        <button
          onClick={() => navigate('/upload')}
          className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 text-sm group hover:scale-105 active:scale-95 focus-visible-ring ${
            isOnPage('/upload')
              ? 'bg-gradient-to-r from-blue-50 to-blue-100 text-blue-700 font-semibold shadow-md border border-blue-300'
              : 'text-slate-600 hover:bg-slate-100 hover:text-slate-900'
          }`}
          aria-label="Upload audio files"
          aria-current={isOnPage('/upload') ? 'page' : undefined}
        >
          <FiUploadCloud size={16} className="group-hover:scale-110 transition-transform flex-shrink-0" aria-hidden="true" />
          <span>Upload</span>
          {isOnPage('/upload') && (
            <div className="ml-auto flex items-center gap-2">
              <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse" aria-hidden="true" />
              <div className="w-1.5 h-1.5 bg-blue-600 rounded-full" aria-hidden="true" />
            </div>
          )}
        </button>
        <button
          onClick={() => navigate('/')}
          className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg transition-all duration-200 text-sm group hover:scale-105 active:scale-95 focus-visible-ring ${
            isOnPage('/')
              ? 'bg-gradient-to-r from-blue-50 to-blue-100 text-blue-700 font-semibold shadow-md border border-blue-300'
              : 'text-slate-600 hover:bg-slate-100 hover:text-slate-900'
          }`}
          aria-label="Go to home page"
          aria-current={isOnPage('/') ? 'page' : undefined}
        >
          <FiHome size={16} className="group-hover:scale-110 transition-transform flex-shrink-0" aria-hidden="true" />
          <span>Home</span>
          {isOnPage('/') && (
            <div className="ml-auto flex items-center gap-2">
              <div className="w-2 h-2 bg-blue-600 rounded-full animate-pulse" aria-hidden="true" />
              <div className="w-1.5 h-1.5 bg-blue-600 rounded-full" aria-hidden="true" />
            </div>
          )}
        </button>
      </div>
    </nav>
  )
}

export const ChatSidebar = memo(ChatSidebarComponent)



================================================================================
FILE: src/components/ConversationItem.tsx
================================================================================
import React, { useState, useRef, useEffect, memo, useCallback } from 'react'
import { FiTrash2, FiEdit2, FiCheck, FiX } from 'react-icons/fi'
import type { Conversation } from '../types'

interface ConversationItemProps {
  conversation: Conversation
  isActive: boolean
  onSelect: (id: string) => void
  onDelete: (id: string) => void
  onRename: (id: string, newTitle: string) => void
}

const ConversationItemComponent: React.FC<ConversationItemProps> = ({
  conversation,
  isActive,
  onSelect,
  onDelete,
  onRename,
}) => {
  const [isEditing, setIsEditing] = useState(false)
  const [editValue, setEditValue] = useState(conversation.title)
  const [isHovering, setIsHovering] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus()
      inputRef.current.select()
    }
  }, [isEditing])

  const handleRename = useCallback(() => {
    const trimmedValue = editValue.trim()
    if (!trimmedValue) {
      setEditValue(conversation.title)
      setIsEditing(false)
      return
    }
    if (trimmedValue !== conversation.title && trimmedValue.length > 0 && trimmedValue.length <= 100) {
      onRename(conversation.id, trimmedValue)
    }
    setIsEditing(false)
    setEditValue(conversation.title)
  }, [editValue, conversation.title, conversation.id, onRename])

  const handleCancel = useCallback(() => {
    setIsEditing(false)
    setEditValue(conversation.title)
  }, [conversation.title])

  const handleDelete = useCallback(() => {
    if (window.confirm(`Delete "${conversation.title}"?`)) {
      onDelete(conversation.id)
    }
  }, [conversation.title, conversation.id, onDelete])

  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleRename()
    } else if (e.key === 'Escape') {
      handleCancel()
    }
  }, [handleRename, handleCancel])

  if (isEditing) {
    return (
      <div className="w-full px-2 py-1.5 rounded-lg bg-blue-50 border border-blue-300 flex items-center gap-1.5">
        <input
          ref={inputRef}
          type="text"
          value={editValue}
          onChange={(e) => {
            if (e.target.value.length <= 100) {
              setEditValue(e.target.value)
            }
          }}
          onKeyDown={handleKeyDown}
          maxLength={100}
          className="flex-1 bg-transparent text-slate-900 text-xs outline-none placeholder-slate-500"
          placeholder="Rename..."
          aria-label="Edit conversation title"
        />
        <button
          onClick={handleRename}
          className="p-1 hover:bg-green-100 rounded transition-colors text-green-600 hover:text-green-700"
          title="Save"
          aria-label="Save rename"
        >
          <FiCheck size={14} />
        </button>
        <button
          onClick={handleCancel}
          className="p-1 hover:bg-red-100 rounded transition-colors text-red-600 hover:text-red-700"
          title="Cancel"
          aria-label="Cancel rename"
        >
          <FiX size={14} />
        </button>
      </div>
    )
  }

  return (
    <div
      onMouseEnter={() => setIsHovering(true)}
      onMouseLeave={() => setIsHovering(false)}
      className="group relative"
    >
      <button
        onClick={() => onSelect(conversation.id)}
        className={`w-full text-left px-2 py-1.5 rounded-lg transition-all duration-200 truncate text-xs font-medium flex items-center gap-2 ${
          isActive
            ? 'bg-blue-100 text-blue-900 shadow-sm hover:shadow-md hover:scale-105 active:scale-95'
            : 'text-slate-600 hover:bg-slate-100 hover:text-slate-900 hover:scale-105 active:scale-95'
        }`}
        title={conversation.title}
        aria-label={`Load conversation: ${conversation.title}`}
        aria-current={isActive ? 'page' : undefined}
      >
        <span
          className={`w-1.5 h-1.5 rounded-full transition-all flex-shrink-0 ${
            isActive ? 'bg-blue-600' : 'bg-slate-400 group-hover:bg-slate-500'
          }`}
          aria-hidden="true"
        />
        <span className="truncate flex-1">{conversation.title}</span>
      </button>

      {/* Hover Actions */}
      {isHovering && !isActive && (
        <div className="absolute right-1 top-1/2 -translate-y-1/2 flex items-center gap-0.5 bg-white/90 backdrop-blur-sm rounded p-0.5 border border-slate-200 shadow-md animate-fade-in">
          <button
            onClick={() => setIsEditing(true)}
            className="p-1 hover:bg-blue-100 rounded transition-colors text-slate-600 hover:text-blue-600"
            title="Rename"
            aria-label="Rename conversation"
          >
            <FiEdit2 size={12} />
          </button>
          <button
            onClick={handleDelete}
            className="p-1 hover:bg-red-100 rounded transition-colors text-slate-600 hover:text-red-600"
            title="Delete"
            aria-label="Delete conversation"
          >
            <FiTrash2 size={12} />
          </button>
        </div>
      )}

      {/* Show actions on active item on hover */}
      {isHovering && isActive && (
        <div className="absolute right-1 top-1/2 -translate-y-1/2 flex items-center gap-0.5 bg-blue-200/90 backdrop-blur-sm rounded p-0.5 border border-blue-300 shadow-md animate-fade-in">
          <button
            onClick={() => setIsEditing(true)}
            className="p-1 hover:bg-blue-300 rounded transition-colors text-blue-700 hover:text-blue-900"
            title="Rename"
            aria-label="Rename conversation"
          >
            <FiEdit2 size={12} />
          </button>
          <button
            onClick={handleDelete}
            className="p-1 hover:bg-red-200 rounded transition-colors text-blue-700 hover:text-red-600"
            title="Delete"
            aria-label="Delete conversation"
          >
            <FiTrash2 size={12} />
          </button>
        </div>
      )}
    </div>
  )
}

export const ConversationItem = memo(ConversationItemComponent)


================================================================================
FILE: src/components/ErrorBoundary.tsx
================================================================================
import React, { type ReactNode } from 'react'
import { FiAlertTriangle, FiRefreshCw, FiRotateCcw } from 'react-icons/fi'
import { logger } from '../services/logger'

interface ErrorBoundaryProps {
  children: ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
}

/**
 * Error Boundary component for catching and displaying React errors
 * Provides options to recover from errors gracefully
 */
export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    logger.error('Error caught by boundary', { error: error.message, componentStack: errorInfo.componentStack })
  }

  handleReset = (): void => {
    this.setState({ hasError: false, error: null })
  }

  handleReload = (): void => {
    window.location.reload()
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="h-screen flex items-center justify-center bg-gradient-to-b from-white to-slate-50 p-4">
          <div className="text-center max-w-md">
            <div className="w-16 h-16 mx-auto bg-red-100 rounded-full flex items-center justify-center mb-6 shadow-lg">
              <FiAlertTriangle size={32} className="text-red-600" aria-hidden="true" />
            </div>
            <h1 className="text-3xl font-bold text-slate-900 mb-3">Something went wrong</h1>
            <p className="text-slate-600 mb-2 text-sm">
              {this.state.error?.message || 'An unexpected error occurred'}
            </p>
            <p className="text-slate-500 text-xs mb-8">
              Please try one of the options below to recover.
            </p>
            <div className="flex flex-col gap-3 justify-center">
              <button
                onClick={this.handleReset}
                className="inline-flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all duration-200 shadow-md hover:shadow-lg hover:scale-105 active:scale-95 font-medium"
                aria-label="Try again"
              >
                <FiRefreshCw size={18} />
                Try Again
              </button>
              <button
                onClick={this.handleReload}
                className="inline-flex items-center justify-center gap-2 px-6 py-3 bg-slate-600 text-white rounded-lg hover:bg-slate-700 transition-all duration-200 shadow-md hover:shadow-lg hover:scale-105 active:scale-95 font-medium"
                aria-label="Reload page"
              >
                <FiRotateCcw size={18} />
                Reload Page
              </button>
              <button
                onClick={() => window.location.href = '/'}
                className="px-6 py-3 bg-slate-200 text-slate-900 rounded-lg hover:bg-slate-300 transition-all duration-200 shadow-sm hover:shadow-md hover:scale-105 active:scale-95 font-medium"
                aria-label="Go to home page"
              >
                Go Home
              </button>
            </div>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}



================================================================================
FILE: src/components/landing/LandingBenefits.tsx
================================================================================
import React, { memo } from 'react'
import { FiTrendingUp, FiClock, FiShield, FiZap } from 'react-icons/fi'

interface Benefit {
  icon: React.ComponentType<{ className?: string }>
  title: string
  description: string
}

const LandingBenefitsComponent: React.FC = () => {
  const benefits: Benefit[] = [
    {
      icon: FiTrendingUp,
      title: 'Increased Efficiency',
      description: 'Process voice notes 10x faster with AI-powered analysis, reducing manual review time and accelerating underwriting decisions.',
    },
    {
      icon: FiClock,
      title: 'Time Savings',
      description: 'Spend less time transcribing and organizing notes. Focus on what matters: making informed underwriting decisions.',
    },
    {
      icon: FiShield,
      title: 'Consistent Quality',
      description: 'Ensure consistent evaluation criteria across all voice notes with standardized AI analysis and insights.',
    },
    {
      icon: FiZap,
      title: 'Instant Insights',
      description: 'Get immediate answers to complex questions about your voice notes and conversations with natural language queries.',
    },
  ]

  return (
    <section className="py-24 sm:py-32 lg:py-40 px-4 sm:px-6 bg-gradient-to-b from-slate-900 via-slate-950 to-slate-900 relative overflow-hidden">
      {/* Decorative background elements */}
      <div className="absolute inset-0 -z-10 overflow-hidden">
        <div className="absolute top-1/4 left-0 w-96 h-96 bg-blue-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-1/4 right-0 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl" />
      </div>

      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-20 sm:mb-24">
          <h2 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-white mb-6">
            Real Benefits for Your Team
          </h2>
          <p className="text-lg sm:text-xl text-slate-300 max-w-3xl mx-auto font-medium">
            Transform how your underwriting team works with AI-powered voice note analysis and intelligent conversations.
          </p>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 sm:gap-8">
          {benefits.map((benefit, index) => {
            const IconComponent = benefit.icon
            return (
              <div
                key={index}
                className="group relative bg-gradient-to-br from-slate-800/50 to-slate-900/50 rounded-2xl p-8 shadow-lg shadow-slate-950/50 border border-blue-500/20 hover:shadow-2xl hover:shadow-blue-500/30 hover:border-blue-400/50 transition-all duration-300 hover:-translate-y-2 focus-within:ring-2 focus-within:ring-blue-500 animate-fade-in-up overflow-hidden backdrop-blur-sm"
                style={{ animationDelay: `${index * 100}ms` }}
              >
                {/* Gradient overlay on hover */}
                <div className="absolute inset-0 bg-gradient-to-br from-blue-500/0 to-cyan-500/0 group-hover:from-blue-500/10 group-hover:to-cyan-500/10 transition-all duration-300 -z-10" />

                <div className="w-14 h-14 bg-gradient-to-br from-blue-500/20 to-cyan-500/20 rounded-xl flex items-center justify-center mb-5 group-hover:from-blue-400/30 group-hover:to-cyan-400/30 transition-all duration-300 shadow-md shadow-blue-500/20 flex-shrink-0">
                  <IconComponent className="w-7 h-7 text-blue-400 group-hover:text-blue-300 transition-colors" aria-hidden="true" />
                </div>
                <h3 className="text-lg sm:text-xl font-bold text-white mb-3 group-hover:text-blue-300 transition-colors">
                  {benefit.title}
                </h3>
                <p className="text-slate-300 text-sm sm:text-base leading-relaxed">
                  {benefit.description}
                </p>
              </div>
            )
          })}
        </div>
      </div>
    </section>
  )
}

export const LandingBenefits = memo(LandingBenefitsComponent)



================================================================================
FILE: src/components/landing/LandingFeatures.tsx
================================================================================
import React, { memo } from 'react'
import { IoChatbubblesOutline } from 'react-icons/io5'
import { HiOutlineDocumentText, HiOutlineMicrophone } from 'react-icons/hi2'

interface Feature {
  icon: React.ComponentType<{ className?: string }>
  title: string
  description: string
}

const LandingFeaturesComponent: React.FC = () => {
  const features: Feature[] = [
    {
      icon: IoChatbubblesOutline,
      title: 'Conversational AI Insights',
      description: 'Ask questions naturally and get instant insights from your voice notes with advanced NLP.',
    },
    {
      icon: HiOutlineDocumentText,
      title: 'Smart Chat History',
      description: 'Access and review all your previous conversations in one organized, searchable place.',
    },
    {
      icon: HiOutlineMicrophone,
      title: 'Audio Upload & Processing',
      description: 'Upload voice notes and let AI extract key information automatically in seconds.',
    },
  ]

  return (
    <section className="py-24 sm:py-32 lg:py-40 px-4 sm:px-6 bg-gradient-to-b from-slate-900 via-slate-950 to-slate-900 relative overflow-hidden">
      {/* Decorative background elements */}
      <div className="absolute inset-0 -z-10 overflow-hidden">
        <div className="absolute top-1/3 right-0 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-0 left-1/3 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl" />
      </div>

      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-20 sm:mb-24">
          <h2 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-white mb-6">
            Powerful Features
          </h2>
          <p className="text-lg sm:text-xl text-slate-300 max-w-3xl mx-auto font-medium">
            Everything you need to transform voice notes into actionable underwriting insights.
          </p>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8 sm:gap-10">
          {features.map((feature, index) => {
            const IconComponent = feature.icon
            return (
              <div
                key={index}
                className="group relative bg-gradient-to-br from-slate-800/50 to-slate-900/50 rounded-2xl p-8 sm:p-10 shadow-lg shadow-slate-950/50 border border-cyan-500/20 hover:shadow-2xl hover:shadow-cyan-500/30 hover:border-cyan-400/50 transition-all duration-300 hover:-translate-y-2 focus-within:ring-2 focus-within:ring-cyan-500 animate-fade-in-up overflow-hidden backdrop-blur-sm"
                style={{ animationDelay: `${index * 100}ms` }}
              >
                {/* Gradient overlay on hover */}
                <div className="absolute inset-0 bg-gradient-to-br from-cyan-500/0 to-blue-500/0 group-hover:from-cyan-500/10 group-hover:to-blue-500/10 transition-all duration-300 -z-10" />

                <div className="w-16 h-16 bg-gradient-to-br from-cyan-500/20 to-blue-500/20 rounded-2xl flex items-center justify-center mb-6 group-hover:from-cyan-400/30 group-hover:to-blue-400/30 transition-all duration-300 shadow-md shadow-cyan-500/20 flex-shrink-0">
                  <IconComponent className="w-8 h-8 text-cyan-400 group-hover:text-cyan-300 transition-colors" aria-hidden="true" />
                </div>
                <h3 className="text-xl sm:text-2xl font-bold text-white mb-4 group-hover:text-cyan-300 transition-colors">
                  {feature.title}
                </h3>
                <p className="text-slate-300 text-base leading-relaxed">
                  {feature.description}
                </p>
              </div>
            )
          })}
        </div>
      </div>
    </section>
  )
}

export const LandingFeatures = memo(LandingFeaturesComponent)



================================================================================
FILE: src/components/landing/LandingFooter.tsx
================================================================================
import React, { memo } from 'react'
import { useNavigate } from 'react-router-dom'

const LandingFooterComponent: React.FC = () => {
  const navigate = useNavigate()
  const currentYear = new Date().getFullYear()

  const links = [
    { label: 'Start Chatting', path: '/chat' },
    { label: 'Upload Audio', path: '/upload' },
    { label: 'Chat History', path: '/history' },
  ]

  return (
    <footer className="border-t border-slate-800/50 bg-gradient-to-b from-slate-900 to-slate-950 py-12 sm:py-16 px-4 sm:px-6">
      <div className="max-w-6xl mx-auto">
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8 mb-8 sm:mb-12">
          {/* Brand */}
          <div>
            <div className="flex items-center gap-3 mb-4">
              <div className="w-10 h-10 bg-gradient-to-br from-cyan-400 to-blue-500 rounded-lg flex items-center justify-center text-slate-950 font-bold shadow-md shadow-cyan-500/50">
                CNA
              </div>
              <div>
                <h3 className="text-lg font-semibold text-white">
                  Marlamade
                </h3>
              </div>
            </div>
            <p className="text-sm text-slate-400">
              Transform voice notes into actionable underwriting insights with advanced AI.
            </p>
          </div>

          {/* Quick Links */}
          <div>
            <h4 className="font-semibold text-white mb-4">Quick Links</h4>
            <ul className="space-y-2">
              {links.map((link) => (
                <li key={link.path}>
                  <button
                    onClick={() => navigate(link.path)}
                    className="text-sm text-slate-400 hover:text-cyan-400 transition-colors duration-200 focus-visible-ring rounded px-2 py-1"
                  >
                    {link.label}
                  </button>
                </li>
              ))}
            </ul>
          </div>

          {/* Legal */}
          <div>
            <h4 className="font-semibold text-white mb-4">Legal</h4>
            <p className="text-xs text-slate-400">
              For internal CNA pilot use only. All data is encrypted and securely stored.
            </p>
          </div>
        </div>

        {/* Bottom */}
        <div className="border-t border-slate-800/50 pt-8 flex flex-col sm:flex-row items-center justify-between gap-4">
          <p className="text-xs text-slate-500">
            Â© {currentYear} CNA. All rights reserved.
          </p>
          <p className="text-xs text-slate-500">
            Enterprise-grade security â€¢ Real-time insights â€¢ Secure by default
          </p>
        </div>
      </div>
    </footer>
  )
}

export const LandingFooter = memo(LandingFooterComponent)



================================================================================
FILE: src/components/landing/LandingHero.tsx
================================================================================
import React, { memo, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { FiArrowRight, FiPlay } from 'react-icons/fi'

const LandingHeroComponent: React.FC = () => {
  const navigate = useNavigate()
  const [isHovering, setIsHovering] = useState(false)

  return (
    <section className="relative py-20 sm:py-28 lg:py-36 px-4 sm:px-6 overflow-hidden">
      {/* Enhanced animated gradient background with multiple layers */}
      <div className="absolute inset-0 -z-10 overflow-hidden">
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-cyan-500/20 rounded-full blur-3xl animate-blob" />
        <div className="absolute bottom-0 left-1/4 w-96 h-96 bg-purple-500/20 rounded-full blur-3xl animate-blob animation-delay-2000" />
        <div className="absolute top-1/2 right-0 w-80 h-80 bg-blue-500/15 rounded-full blur-3xl animate-blob" style={{ animationDelay: '4s' }} />
      </div>

      <div className="max-w-7xl mx-auto">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-12 lg:gap-20 items-center">
          {/* Left: Text & CTAs */}
          <div className="flex flex-col justify-center space-y-8 animate-fade-in-up">
            {/* Badge */}
            <div className="inline-flex items-center gap-2 w-fit px-4 py-2 bg-cyan-500/10 border border-cyan-500/30 rounded-full">
              <div className="w-2 h-2 bg-cyan-400 rounded-full animate-pulse" />
              <span className="text-sm font-medium text-cyan-300">AI-Powered Voice Analysis</span>
            </div>

            <div>
              <h1 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-white mb-6 leading-tight tracking-tight">
                Transform Voice
                <span className="block bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent mt-3">
                  Into Insights
                </span>
              </h1>
              <p className="text-lg sm:text-xl text-slate-300 leading-relaxed max-w-2xl font-medium">
                Analyze underwriting voice memos with AI-powered intelligence. Extract key insights instantly. Make data-driven decisions that improve win rates.
              </p>
            </div>

            <div className="flex gap-3 sm:gap-4 flex-wrap pt-8">
              <button
                onClick={() => navigate('/chat')}
                className="group px-8 sm:px-10 py-4 sm:py-5 bg-gradient-to-r from-cyan-400 to-blue-500 text-slate-950 rounded-xl font-bold shadow-xl shadow-cyan-500/60 hover:shadow-2xl hover:shadow-cyan-400/80 hover:from-cyan-300 hover:to-blue-400 transition-all duration-300 hover:scale-105 active:scale-95 flex items-center gap-2 text-base sm:text-lg focus-visible-ring"
              >
                <span>Start Chatting</span>
                <FiArrowRight className="group-hover:translate-x-2 transition-transform" size={20} />
              </button>
              <button
                onClick={() => navigate('/upload')}
                className="group px-8 sm:px-10 py-4 sm:py-5 bg-slate-700/80 text-cyan-200 border-2 border-cyan-400/60 rounded-xl font-semibold hover:bg-slate-600 hover:border-cyan-300 hover:text-cyan-100 transition-all duration-300 hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl hover:shadow-cyan-500/40 text-base sm:text-lg focus-visible-ring flex items-center gap-2 backdrop-blur-sm"
              >
                <FiPlay size={18} />
                <span>Upload Audio</span>
              </button>
            </div>
          </div>

          {/* Right: Interactive Visual Hero Element */}
          <div className="hidden lg:flex items-center justify-center animate-fade-in stagger-2">
            <div
              className="relative w-full max-w-md h-96 cursor-pointer"
              onMouseEnter={() => setIsHovering(true)}
              onMouseLeave={() => setIsHovering(false)}
            >
              {/* Glassmorphic background with dark theme */}
              <div className={`absolute inset-0 bg-gradient-to-br from-slate-800/50 to-slate-900/50 rounded-3xl backdrop-blur-xl border border-cyan-500/30 shadow-2xl shadow-cyan-500/20 transition-all duration-500 ${isHovering ? 'shadow-cyan-400/50 scale-105 border-cyan-400/50' : ''}`} />

              {/* Animated border glow on hover */}
              {isHovering && (
                <div className="absolute inset-0 rounded-3xl bg-gradient-to-br from-cyan-400/20 to-blue-400/20 blur-xl animate-pulse" />
              )}

              {/* Mock chat panel with dark theme */}
              <div className="absolute inset-4 flex flex-col">
                <div className="h-10 bg-slate-700/50 rounded-lg mb-4" />
                <div className="flex-1 space-y-4 overflow-hidden">
                  <div className="h-8 bg-cyan-500/20 rounded-lg w-3/4 animate-pulse" />
                  <div className="h-8 bg-slate-600/30 rounded-lg w-4/5 animate-pulse" style={{ animationDelay: '0.2s' }} />
                  <div className="h-8 bg-cyan-500/20 rounded-lg w-2/3 animate-pulse" style={{ animationDelay: '0.4s' }} />
                </div>
              </div>

              {/* Floating insight cards with dark theme */}
              <div className="absolute -bottom-8 -right-8 bg-slate-800 rounded-2xl p-5 shadow-2xl shadow-cyan-500/30 border border-cyan-500/30 backdrop-blur-sm max-w-xs hover:shadow-2xl hover:shadow-cyan-400/50 transition-all duration-300 hover:scale-110 hover:-translate-y-2">
                <div className="text-xs font-bold text-cyan-300 mb-4 uppercase tracking-wider">Key Insights</div>
                <div className="space-y-3 text-xs text-slate-300">
                  <div className="flex items-center gap-3">
                    <div className="w-2.5 h-2.5 bg-cyan-400 rounded-full" />
                    <span className="font-medium">Broker: Marsh & McLennan</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <div className="w-2.5 h-2.5 bg-purple-400 rounded-full" />
                    <span className="font-medium">LOB: Workers Comp</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  )
}

export const LandingHero = memo(LandingHeroComponent)



================================================================================
FILE: src/components/landing/LandingHowItWorks.tsx
================================================================================
import React, { memo } from 'react'
import { HiOutlineMicrophone, HiOutlineSparkles, HiOutlineQuestionMarkCircle } from 'react-icons/hi2'

interface Step {
  number: number
  title: string
  description: string
  icon: React.ComponentType<{ className?: string }>
}

const LandingHowItWorksComponent: React.FC = () => {
  const steps: Step[] = [
    {
      number: 1,
      title: 'Record or Upload a Call',
      description: 'Upload your underwriting call recordings or voice notes directly to the platform.',
      icon: HiOutlineMicrophone,
    },
    {
      number: 2,
      title: 'AI Transcribes & Understands',
      description: 'Advanced AI transcribes and analyzes the conversation to extract key information.',
      icon: HiOutlineSparkles,
    },
    {
      number: 3,
      title: 'Ask Questions & Act',
      description: 'Chat with the AI to ask questions and get actionable insights instantly.',
      icon: HiOutlineQuestionMarkCircle,
    },
  ]

  return (
    <section className="py-24 sm:py-32 lg:py-40 px-4 sm:px-6 bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 relative overflow-hidden">
      {/* Decorative background */}
      <div className="absolute inset-0 -z-10 overflow-hidden">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-1/3 right-0 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl" />
      </div>

      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-20 sm:mb-24">
          <h2 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-white mb-6">
            How It Works
          </h2>
          <p className="text-lg sm:text-xl text-slate-300 max-w-3xl mx-auto font-medium">
            Three simple steps to transform your voice notes into actionable insights.
          </p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-10 md:gap-8">
          {steps.map((step, index) => {
            const IconComponent = step.icon
            return (
              <div key={index} className="relative animate-fade-in-up" style={{ animationDelay: `${index * 100}ms` }}>
                {/* Connecting line (hidden on mobile) */}
                {index < steps.length - 1 && (
                  <div className="hidden md:block absolute top-20 left-1/2 w-full h-1.5 bg-gradient-to-r from-cyan-400/50 via-blue-400/30 to-transparent transform -translate-y-1/2" />
                )}

                <div className="relative flex flex-col items-center text-center">
                  {/* Number badge with enhanced styling */}
                  <div className="w-20 h-20 bg-gradient-to-br from-cyan-500 to-blue-500 rounded-full flex items-center justify-center text-slate-950 font-bold text-2xl shadow-lg shadow-cyan-500/50 mb-8 flex-shrink-0 relative z-10 hover:scale-110 transition-transform duration-300 hover:shadow-2xl hover:shadow-cyan-400/70">
                    {step.number}
                  </div>

                  {/* Icon container */}
                  <div className="w-20 h-20 bg-gradient-to-br from-cyan-500/20 to-blue-500/20 rounded-3xl flex items-center justify-center mb-8 shadow-md shadow-cyan-500/20 hover:shadow-lg hover:shadow-cyan-400/30 transition-all duration-300 border border-cyan-500/30">
                    <IconComponent className="w-10 h-10 text-cyan-400" aria-hidden="true" />
                  </div>

                  {/* Content */}
                  <h3 className="text-xl sm:text-2xl font-bold text-white mb-4">
                    {step.title}
                  </h3>
                  <p className="text-slate-300 text-base leading-relaxed">
                    {step.description}
                  </p>
                </div>
              </div>
            )
          })}
        </div>
      </div>
    </section>
  )
}

export const LandingHowItWorks = memo(LandingHowItWorksComponent)



================================================================================
FILE: src/components/landing/LandingInsightPreview.tsx
================================================================================
import React, { memo } from 'react'

const LandingInsightPreviewComponent: React.FC = () => {
  return (
    <section className="py-24 sm:py-32 lg:py-40 px-4 sm:px-6 bg-gradient-to-b from-slate-900 via-slate-950 to-slate-900 relative overflow-hidden">
      {/* Decorative background */}
      <div className="absolute inset-0 -z-10 overflow-hidden">
        <div className="absolute top-1/4 right-0 w-96 h-96 bg-cyan-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-0 left-1/4 w-80 h-80 bg-purple-500/10 rounded-full blur-3xl" />
      </div>

      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-20 sm:mb-24">
          <h2 className="text-5xl sm:text-6xl lg:text-7xl font-bold text-white mb-6">
            See It In Action
          </h2>
          <p className="text-lg sm:text-xl text-slate-300 max-w-3xl mx-auto font-medium">
            Get instant insights from your underwriting conversations.
          </p>
        </div>

        <div className="relative animate-fade-in-up">
          {/* Main preview card with dark theme */}
          <div className="bg-gradient-to-br from-slate-800/50 to-slate-900/50 rounded-3xl border border-cyan-500/30 shadow-2xl shadow-cyan-500/20 overflow-hidden hover:shadow-3xl hover:shadow-cyan-400/30 transition-all duration-300 hover:-translate-y-1 backdrop-blur-sm">
            <div className="p-8 sm:p-10 lg:p-12">
              <div className="grid grid-cols-1 lg:grid-cols-3 gap-10">
                {/* Chat preview */}
                <div className="lg:col-span-2">
                  <div className="space-y-6">
                    <div className="flex justify-end">
                      <div className="bg-gradient-to-r from-cyan-500 to-blue-500 text-slate-950 rounded-3xl rounded-tr-none px-6 py-4 max-w-xs shadow-lg shadow-cyan-500/50">
                        <p className="text-base font-medium">What were the key discussion points?</p>
                      </div>
                    </div>
                    <div className="flex justify-start">
                      <div className="bg-gradient-to-br from-slate-700/50 to-slate-800/50 text-slate-100 rounded-3xl rounded-tl-none px-6 py-4 max-w-xs shadow-md border border-slate-600/50">
                        <p className="text-base font-bold mb-4">Key Points:</p>
                        <ul className="text-sm space-y-3">
                          <li className="flex items-start gap-3">
                            <span className="text-cyan-400 font-bold mt-0.5">â€¢</span>
                            <span>Coverage limits discussed</span>
                          </li>
                          <li className="flex items-start gap-3">
                            <span className="text-cyan-400 font-bold mt-0.5">â€¢</span>
                            <span>Loss history reviewed</span>
                          </li>
                          <li className="flex items-start gap-3">
                            <span className="text-cyan-400 font-bold mt-0.5">â€¢</span>
                            <span>Premium negotiation pending</span>
                          </li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Insights sidebar */}
                <div className="space-y-5">
                  <h3 className="text-xs font-bold text-cyan-300 mb-6 uppercase tracking-widest">Extracted Insights</h3>
                  <div className="space-y-4">
                    <div className="bg-gradient-to-br from-cyan-500/20 to-cyan-600/10 border border-cyan-500/40 rounded-2xl p-5 hover:shadow-lg hover:shadow-cyan-500/30 transition-all duration-300 hover:-translate-y-1">
                      <div className="text-xs font-bold text-cyan-300 uppercase tracking-widest">Broker</div>
                      <div className="text-base font-bold text-cyan-200 mt-3">Marsh & McLennan</div>
                    </div>
                    <div className="bg-gradient-to-br from-purple-500/20 to-purple-600/10 border border-purple-500/40 rounded-2xl p-5 hover:shadow-lg hover:shadow-purple-500/30 transition-all duration-300 hover:-translate-y-1">
                      <div className="text-xs font-bold text-purple-300 uppercase tracking-widest">LOB</div>
                      <div className="text-base font-bold text-purple-200 mt-3">Workers Compensation</div>
                    </div>
                    <div className="bg-gradient-to-br from-blue-500/20 to-blue-600/10 border border-blue-500/40 rounded-2xl p-5 hover:shadow-lg hover:shadow-blue-500/30 transition-all duration-300 hover:-translate-y-1">
                      <div className="text-xs font-bold text-blue-300 uppercase tracking-widest">Next Steps</div>
                      <div className="text-base font-bold text-blue-200 mt-3">Follow up on loss runs</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  )
}

export const LandingInsightPreview = memo(LandingInsightPreviewComponent)



================================================================================
FILE: src/components/LayoutShell.tsx
================================================================================
import React, { useEffect } from 'react'
import type { ReactNode } from 'react'

interface LayoutShellProps {
  children: ReactNode
}

/**
 * Global layout shell that applies global styles
 * Should wrap the entire application
 */
const LayoutShellComponent: React.FC<LayoutShellProps> = ({ children }) => {
  // Ensure light theme is applied on mount
  useEffect(() => {
    const htmlElement = document.documentElement
    htmlElement.classList.remove('dark')
  }, [])

  return (
    <div>
      <style>{`
        :root {
          color-scheme: light;
        }

        @media (prefers-reduced-motion: reduce) {
          * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
          }
        }
      `}</style>
      {children}
    </div>
  )
}

export const LayoutShell = React.memo(LayoutShellComponent)



================================================================================
FILE: src/components/LoadingSpinner.tsx
================================================================================
import React, { memo } from 'react'

const LoadingSpinnerComponent: React.FC = () => {
  return (
    <div className="flex justify-start animate-slide-in-left" aria-live="polite" aria-label="Assistant is thinking">
      <div className="bg-slate-100 text-slate-900 px-5 py-3.5 rounded-2xl rounded-bl-none shadow-md border border-slate-200 hover:shadow-lg transition-all duration-200">
        <div className="flex items-center gap-3">
          {/* Sleek Animated Dots with Wave Effect */}
          <div className="flex gap-1.5 items-center h-5">
            <div
              className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot"
              style={{ animationDelay: '0s' }}
              aria-hidden="true"
            />
            <div
              className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot"
              style={{ animationDelay: '0.15s' }}
              aria-hidden="true"
            />
            <div
              className="w-2.5 h-2.5 bg-gradient-to-b from-blue-500 to-blue-600 rounded-full shadow-md animate-wave-dot"
              style={{ animationDelay: '0.3s' }}
              aria-hidden="true"
            />
          </div>

          {/* Thinking Text with Smooth Ellipsis */}
          <span className="text-sm font-semibold text-slate-700 tracking-wide">
            Thinking<span className="inline-block animate-thinking-dots w-3 text-left">.</span>
          </span>
        </div>
      </div>
    </div>
  )
}

export const LoadingSpinner = memo(LoadingSpinnerComponent)



================================================================================
FILE: src/components/MessageRenderer.tsx
================================================================================
import React, { useMemo, memo } from 'react'
import { detectContentType } from '../utils/responseFormatter'

interface MessageRendererProps {
  content: string
}

/**
 * Enhanced message renderer that handles different content types
 * Supports text, markdown, and JSON formatting
 */
const MessageRendererComponent: React.FC<MessageRendererProps> = ({ content }) => {
  const contentType = useMemo(() => detectContentType(content), [content])

  // Render markdown-like content
  const renderMarkdown = (text: string) => {
    let processedText = text

    // Process code blocks first (to avoid processing markdown inside code)
    processedText = processedText.replace(/```([\s\S]*?)```/g, '<pre><code class="language-text">$1</code></pre>')

    // Process bold
    processedText = processedText.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-slate-900">$1</strong>')

    // Process italic
    processedText = processedText.replace(/\*(.*?)\*/g, '<em class="italic text-slate-800">$1</em>')

    // Process inline code
    processedText = processedText.replace(/`(.*?)`/g, '<code class="bg-slate-100 px-2 py-1 rounded text-sm font-mono text-slate-900">$1</code>')

    // Process headings (h1, h2, h3)
    processedText = processedText.replace(/^### (.*?)$/gm, '<h3 class="text-lg font-semibold text-slate-900 mt-3 mb-2">$1</h3>')
    processedText = processedText.replace(/^## (.*?)$/gm, '<h2 class="text-xl font-bold text-slate-900 mt-4 mb-2">$1</h2>')
    processedText = processedText.replace(/^# (.*?)$/gm, '<h1 class="text-2xl font-bold text-slate-900 mt-4 mb-2">$1</h1>')

    // Process unordered lists
    processedText = processedText.replace(/^\* (.*?)$/gm, '<li class="ml-4 text-slate-800">$1</li>')
    processedText = processedText.replace(/(<li.*?<\/li>)/s, '<ul class="list-disc space-y-1">$1</ul>')

    // Process ordered lists
    processedText = processedText.replace(/^\d+\. (.*?)$/gm, '<li class="ml-4 text-slate-800">$1</li>')

    // Process line breaks
    processedText = processedText.replace(/\n\n/g, '</p><p class="mt-3">')
    processedText = processedText.replace(/\n/g, '<br />')

    return (
      <div
        className="space-y-2 text-sm leading-relaxed"
        dangerouslySetInnerHTML={{ __html: processedText }}
      />
    )
  }

  // Render JSON content
  const renderJson = (text: string) => {
    try {
      const parsed = JSON.parse(text)
      return (
        <pre className="bg-slate-900 text-slate-100 p-4 rounded-lg text-xs overflow-x-auto font-mono border border-slate-700">
          <code>{JSON.stringify(parsed, null, 2)}</code>
        </pre>
      )
    } catch {
      return <p className="whitespace-pre-wrap break-words text-sm leading-relaxed">{text}</p>
    }
  }

  // Render based on content type
  const renderContent = () => {
    switch (contentType) {
      case 'markdown':
        return renderMarkdown(content)
      case 'json':
        return renderJson(content)
      case 'text':
      default:
        return <p className="whitespace-pre-wrap break-words text-sm leading-relaxed">{content}</p>
    }
  }

  return (
    <div className={`message-renderer ${contentType}`}>
      {renderContent()}
    </div>
  )
}

export const MessageRenderer = memo(MessageRendererComponent)



================================================================================
FILE: src/components/MetadataFilters.tsx
================================================================================
import React, { memo, useState, useCallback } from 'react'
import { FiChevronDown, FiX } from 'react-icons/fi'
import type { ConversationMetadata } from '../types'

interface MetadataFiltersProps {
  activeFilters: ConversationMetadata
  onFilterChange: (filters: ConversationMetadata) => void
  availableMetadata?: {
    brokers: string[]
    lobs: string[]
    clients: string[]
  }
}

const MetadataFiltersComponent: React.FC<MetadataFiltersProps> = ({
  activeFilters,
  onFilterChange,
  availableMetadata = {
    brokers: ['Marsh', 'Aon', 'Willis Towers Watson', 'Gallagher'],
    lobs: ['Workers Comp', 'General Liability', 'Property', 'Cyber'],
    clients: [],
  },
}) => {
  const [expandedSection, setExpandedSection] = useState<string | null>(null)

  const toggleSection = useCallback((section: string) => {
    setExpandedSection(expandedSection === section ? null : section)
  }, [expandedSection])

  const handleFilterToggle = useCallback((key: string, value: string | number | boolean) => {
    const valueStr = String(value)
    const currentValues = (activeFilters[key] as string[]) || []
    const newValues = currentValues.includes(valueStr)
      ? currentValues.filter(v => v !== valueStr)
      : [...currentValues, valueStr]

    onFilterChange({
      ...activeFilters,
      [key]: newValues.length > 0 ? newValues : undefined,
    })
  }, [activeFilters, onFilterChange])

  const handleClearAll = useCallback(() => {
    onFilterChange({})
  }, [onFilterChange])

  const hasActiveFilters = Object.values(activeFilters).some(v => v && (Array.isArray(v) ? v.length > 0 : true))

  return (
    <div className="w-64 bg-white border-r border-slate-200 flex flex-col h-full overflow-hidden">
      {/* Header */}
      <div className="p-4 border-b border-slate-200">
        <h3 className="text-sm font-semibold text-slate-900 mb-2">Filters</h3>
        {hasActiveFilters && (
          <button
            onClick={handleClearAll}
            className="text-xs text-blue-600 hover:text-blue-700 font-medium transition-colors"
            type="button"
          >
            Clear all
          </button>
        )}
      </div>

      {/* Filters List */}
      <div className="flex-1 overflow-y-auto">
        {/* Broker Filter */}
        <div className="border-b border-slate-100">
          <button
            onClick={() => toggleSection('broker')}
            className="w-full px-4 py-3 flex items-center justify-between hover:bg-slate-50 transition-colors text-left"
            type="button"
          >
            <span className="text-sm font-medium text-slate-700">Broker</span>
            <FiChevronDown
              size={16}
              className={`text-slate-400 transition-transform ${expandedSection === 'broker' ? 'rotate-180' : ''}`}
            />
          </button>
          {expandedSection === 'broker' && (
            <div className="px-4 py-2 bg-slate-50 space-y-2">
              {availableMetadata.brokers.map(broker => {
                const brokerValues = (Array.isArray(activeFilters.broker) ? activeFilters.broker : []) as string[]
                return (
                  <label key={broker} className="flex items-center gap-2 cursor-pointer group">
                    <input
                      type="checkbox"
                      checked={brokerValues.includes(broker)}
                      onChange={() => handleFilterToggle('broker', broker)}
                      className="w-4 h-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                    />
                    <span className="text-sm text-slate-600 group-hover:text-slate-900 transition-colors">{broker}</span>
                  </label>
                )
              })}
            </div>
          )}
        </div>

        {/* LOB Filter */}
        <div className="border-b border-slate-100">
          <button
            onClick={() => toggleSection('lob')}
            className="w-full px-4 py-3 flex items-center justify-between hover:bg-slate-50 transition-colors text-left"
            type="button"
          >
            <span className="text-sm font-medium text-slate-700">Line of Business</span>
            <FiChevronDown
              size={16}
              className={`text-slate-400 transition-transform ${expandedSection === 'lob' ? 'rotate-180' : ''}`}
            />
          </button>
          {expandedSection === 'lob' && (
            <div className="px-4 py-2 bg-slate-50 space-y-2">
              {availableMetadata.lobs.map(lob => {
                const lobValues = (Array.isArray(activeFilters.lob) ? activeFilters.lob : []) as string[]
                return (
                  <label key={lob} className="flex items-center gap-2 cursor-pointer group">
                    <input
                      type="checkbox"
                      checked={lobValues.includes(lob)}
                      onChange={() => handleFilterToggle('lob', lob)}
                      className="w-4 h-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
                    />
                    <span className="text-sm text-slate-600 group-hover:text-slate-900 transition-colors">{lob}</span>
                  </label>
                )
              })}
            </div>
          )}
        </div>
      </div>

      {/* Active Filters Display */}
      {hasActiveFilters && (
        <div className="p-4 border-t border-slate-200 bg-slate-50">
          <p className="text-xs font-medium text-slate-600 mb-2">Active filters:</p>
          <div className="flex flex-wrap gap-2">
            {Object.entries(activeFilters).map(([key, values]) => {
              if (!values || (Array.isArray(values) && values.length === 0)) return null
              const valueArray = Array.isArray(values) ? values : [values]
              return valueArray.map(value => (
                <div
                  key={`${key}-${value}`}
                  className="inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs font-medium"
                >
                  <span>{value}</span>
                  <button
                    onClick={() => handleFilterToggle(key, value)}
                    className="hover:text-blue-900 transition-colors"
                    type="button"
                    aria-label={`Remove ${value} filter`}
                  >
                    <FiX size={12} />
                  </button>
                </div>
              ))
            })}
          </div>
        </div>
      )}
    </div>
  )
}

export const MetadataFilters = memo(MetadataFiltersComponent)



================================================================================
FILE: src/components/MetadataInputModal.tsx
================================================================================
import React, { useState, memo } from 'react'
import { FiX } from 'react-icons/fi'
import { FILTER_OPTIONS, getFilterLabel } from '../constants/filterOptions'
import type { ConversationMetadata } from '../types'

interface MetadataInputModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: (metadata: Partial<ConversationMetadata>) => void
}

const MetadataInputModalComponent: React.FC<MetadataInputModalProps> = ({ isOpen, onClose, onSubmit }) => {
  const [metadata, setMetadata] = useState<Partial<ConversationMetadata>>({})

  const handleSubmit = () => {
    onSubmit(metadata)
    setMetadata({})
    onClose()
  }

  const handleClose = () => {
    setMetadata({})
    onClose()
  }

  if (!isOpen) return null

  return (
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black/50 z-50"
        onClick={handleClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div className="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] overflow-y-auto">
          {/* Header */}
          <div className="sticky top-0 bg-white border-b border-slate-200 p-4 flex items-center justify-between">
            <h2 className="text-lg font-semibold text-slate-900">Add Metadata (Optional)</h2>
            <button
              onClick={handleClose}
              className="p-1 hover:bg-slate-100 rounded-lg transition-colors"
              aria-label="Close modal"
            >
              <FiX size={20} />
            </button>
          </div>

          {/* Content */}
          <div className="p-4 space-y-4">
            {/* Broker */}
            <div>
              <label className="block text-sm font-medium text-slate-900 mb-2">Broker</label>
              <select
                value={metadata.broker || ''}
                onChange={(e) => setMetadata({ ...metadata, broker: e.target.value || undefined })}
                className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a broker...</option>
                {FILTER_OPTIONS.brokers.map((broker) => (
                  <option key={broker} value={broker}>
                    {broker}
                  </option>
                ))}
              </select>
            </div>

            {/* LOB */}
            <div>
              <label className="block text-sm font-medium text-slate-900 mb-2">Line of Business</label>
              <select
                value={metadata.lob || ''}
                onChange={(e) => setMetadata({ ...metadata, lob: e.target.value || undefined })}
                className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a LOB...</option>
                {FILTER_OPTIONS.lobs.map((lob) => (
                  <option key={lob} value={lob}>
                    {getFilterLabel('lobs', lob)}
                  </option>
                ))}
              </select>
            </div>

            {/* Business Type */}
            <div>
              <label className="block text-sm font-medium text-slate-900 mb-2">Business Type</label>
              <select
                value={metadata.businessType || ''}
                onChange={(e) => setMetadata({ ...metadata, businessType: e.target.value || undefined })}
                className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a type...</option>
                {FILTER_OPTIONS.businessTypes.map((type) => (
                  <option key={type} value={type}>
                    {getFilterLabel('businessTypes', type)}
                  </option>
                ))}
              </select>
            </div>

            {/* Risk Category */}
            <div>
              <label className="block text-sm font-medium text-slate-900 mb-2">Risk Category</label>
              <select
                value={metadata.riskCategory || ''}
                onChange={(e) => setMetadata({ ...metadata, riskCategory: e.target.value || undefined })}
                className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a category...</option>
                {FILTER_OPTIONS.riskCategories.map((category) => (
                  <option key={category} value={category}>
                    {getFilterLabel('riskCategories', category)}
                  </option>
                ))}
              </select>
            </div>

            {/* Underwriting Status */}
            <div>
              <label className="block text-sm font-medium text-slate-900 mb-2">Underwriting Status</label>
              <select
                value={metadata.underwritingStatus || ''}
                onChange={(e) => setMetadata({ ...metadata, underwritingStatus: e.target.value || undefined })}
                className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">Select a status...</option>
                {FILTER_OPTIONS.underwritingStatus.map((status) => (
                  <option key={status} value={status}>
                    {getFilterLabel('underwritingStatus', status)}
                  </option>
                ))}
              </select>
            </div>
          </div>

          {/* Footer */}
          <div className="sticky bottom-0 bg-slate-50 border-t border-slate-200 p-4 flex gap-3">
            <button
              onClick={handleClose}
              className="flex-1 px-4 py-2 text-slate-700 border border-slate-300 rounded-lg hover:bg-slate-100 transition-colors font-medium text-sm"
            >
              Skip
            </button>
            <button
              onClick={handleSubmit}
              className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium text-sm"
            >
              Create
            </button>
          </div>
        </div>
      </div>
    </>
  )
}

export const MetadataInputModal = memo(MetadataInputModalComponent)



================================================================================
FILE: src/components/SkipToContent.tsx
================================================================================
import React, { memo } from 'react'

const SkipToContentComponent: React.FC = () => {
  const handleSkip = () => {
    const mainContent = document.getElementById('main-content')
    if (mainContent) {
      mainContent.focus()
      mainContent.scrollIntoView({ behavior: 'smooth' })
    }
  }

  return (
    <a
      href="#main-content"
      onClick={handleSkip}
      className="absolute top-0 left-0 -translate-y-full focus:translate-y-0 bg-blue-600 text-white px-4 py-2 rounded-b-lg font-semibold transition-transform duration-200 z-50"
    >
      Skip to main content
    </a>
  )
}

export const SkipToContent = memo(SkipToContentComponent)



================================================================================
FILE: src/components/UnderwritingFilters.tsx
================================================================================
import React, { useState, memo } from 'react'
import { FiChevronDown, FiX } from 'react-icons/fi'
import { FILTER_OPTIONS } from '../constants/filterOptions'
import type { ConversationMetadata } from '../types'

interface UnderwritingFiltersProps {
  onFilterChange: (filters: Partial<ConversationMetadata>) => void
  activeFilters: Partial<ConversationMetadata>
  isOpen?: boolean
  onClose?: () => void
}

const UnderwritingFiltersComponent: React.FC<UnderwritingFiltersProps> = ({
  onFilterChange,
  activeFilters,
  isOpen = false,
  onClose,
}) => {
  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({
    broker: true,
    lob: true,
    businessType: false,
    riskCategory: false,
    status: false,
  })

  const toggleSection = (section: string) => {
    setExpandedSections(prev => ({
      ...prev,
      [section]: !prev[section],
    }))
  }

  // Build filter options with "All" prefix for display
  const brokerOptions = ['All Brokers', ...FILTER_OPTIONS.brokers]
  const lobOptions = ['All LOBs', ...FILTER_OPTIONS.lobs]
  const businessTypeOptions = ['All Types', ...FILTER_OPTIONS.businessTypes]
  const riskCategoryOptions = ['All Categories', ...FILTER_OPTIONS.riskCategories]
  const statusOptions = ['All Status', ...FILTER_OPTIONS.underwritingStatus]

  const handleFilterSelect = (filterType: string, value: string) => {
    if (value.startsWith('All ')) {
      const newFilters = { ...activeFilters }
      delete newFilters[filterType as keyof ConversationMetadata]
      onFilterChange(newFilters)
    } else {
      onFilterChange({
        ...activeFilters,
        [filterType]: value,
      })
    }
  }

  const clearAllFilters = () => {
    onFilterChange({})
  }

  const hasActiveFilters = Object.keys(activeFilters).length > 0

  // Desktop sidebar version
  const desktopContent = (
    <div className="w-64 bg-white border-r border-slate-200 overflow-y-auto flex flex-col h-full">
      {/* Header */}
      <div className="sticky top-0 bg-white border-b border-slate-200 p-4 z-10">
        <h3 className="font-semibold text-slate-900 text-sm mb-3">Filters</h3>
        {hasActiveFilters && (
          <button
            onClick={clearAllFilters}
            className="text-xs text-blue-600 hover:text-blue-700 font-medium transition-colors"
            aria-label="Clear all filters"
          >
            Clear All
          </button>
        )}
      </div>

      {/* Filter Sections */}
      <div className="flex-1 overflow-y-auto">
        {/* Broker Filter */}
        <FilterSection
          title="Broker"
          section="broker"
          expanded={expandedSections.broker}
          onToggle={() => toggleSection('broker')}
          options={brokerOptions}
          selectedValue={activeFilters.broker}
          onSelect={(value) => handleFilterSelect('broker', value)}
        />

        {/* LOB Filter */}
        <FilterSection
          title="Line of Business"
          section="lob"
          expanded={expandedSections.lob}
          onToggle={() => toggleSection('lob')}
          options={lobOptions}
          selectedValue={activeFilters.lob}
          onSelect={(value) => handleFilterSelect('lob', value)}
        />

        {/* Business Type Filter */}
        <FilterSection
          title="Business Type"
          section="businessType"
          expanded={expandedSections.businessType}
          onToggle={() => toggleSection('businessType')}
          options={businessTypeOptions}
          selectedValue={activeFilters.businessType}
          onSelect={(value) => handleFilterSelect('businessType', value)}
        />

        {/* Risk Category Filter */}
        <FilterSection
          title="Risk Category"
          section="riskCategory"
          expanded={expandedSections.riskCategory}
          onToggle={() => toggleSection('riskCategory')}
          options={riskCategoryOptions}
          selectedValue={activeFilters.riskCategory}
          onSelect={(value) => handleFilterSelect('riskCategory', value)}
        />

        {/* Underwriting Status Filter */}
        <FilterSection
          title="Underwriting Status"
          section="status"
          expanded={expandedSections.status}
          onToggle={() => toggleSection('status')}
          options={statusOptions}
          selectedValue={activeFilters.underwritingStatus}
          onSelect={(value) => handleFilterSelect('underwritingStatus', value)}
        />
      </div>
    </div>
  )

  // Mobile drawer version
  const mobileDrawer = (
    <>
      {/* Backdrop */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-black/50 z-40 md:hidden"
          onClick={onClose}
          aria-hidden="true"
        />
      )}

      {/* Drawer */}
      <div
        className={`fixed inset-y-0 right-0 w-64 bg-white shadow-lg transform transition-transform duration-300 z-50 md:hidden ${
          isOpen ? 'translate-x-0' : 'translate-x-full'
        }`}
      >
        {/* Close button */}
        <div className="sticky top-0 bg-white border-b border-slate-200 p-4 flex items-center justify-between">
          <h3 className="font-semibold text-slate-900 text-sm">Filters</h3>
          <button
            onClick={onClose}
            className="p-1 hover:bg-slate-100 rounded-lg transition-colors"
            aria-label="Close filters"
          >
            <FiX size={20} />
          </button>
        </div>

        {/* Filter content */}
        <div className="overflow-y-auto h-[calc(100vh-60px)]">
          {hasActiveFilters && (
            <div className="p-4 border-b border-slate-200">
              <button
                onClick={clearAllFilters}
                className="text-xs text-blue-600 hover:text-blue-700 font-medium transition-colors"
                aria-label="Clear all filters"
              >
                Clear All
              </button>
            </div>
          )}

          {/* Filter Sections */}
          <FilterSection
            title="Broker"
            section="broker"
            expanded={expandedSections.broker}
            onToggle={() => toggleSection('broker')}
            options={brokerOptions}
            selectedValue={activeFilters.broker}
            onSelect={(value) => handleFilterSelect('broker', value)}
          />

          <FilterSection
            title="Line of Business"
            section="lob"
            expanded={expandedSections.lob}
            onToggle={() => toggleSection('lob')}
            options={lobOptions}
            selectedValue={activeFilters.lob}
            onSelect={(value) => handleFilterSelect('lob', value)}
          />

          <FilterSection
            title="Business Type"
            section="businessType"
            expanded={expandedSections.businessType}
            onToggle={() => toggleSection('businessType')}
            options={businessTypeOptions}
            selectedValue={activeFilters.businessType}
            onSelect={(value) => handleFilterSelect('businessType', value)}
          />

          <FilterSection
            title="Risk Category"
            section="riskCategory"
            expanded={expandedSections.riskCategory}
            onToggle={() => toggleSection('riskCategory')}
            options={riskCategoryOptions}
            selectedValue={activeFilters.riskCategory}
            onSelect={(value) => handleFilterSelect('riskCategory', value)}
          />

          <FilterSection
            title="Underwriting Status"
            section="status"
            expanded={expandedSections.status}
            onToggle={() => toggleSection('status')}
            options={statusOptions}
            selectedValue={activeFilters.underwritingStatus}
            onSelect={(value) => handleFilterSelect('underwritingStatus', value)}
          />
        </div>
      </div>
    </>
  )

  return (
    <>
      {/* Desktop sidebar - hidden on mobile */}
      <div className="hidden md:flex">
        {desktopContent}
      </div>

      {/* Mobile drawer */}
      <div className="md:hidden">
        {mobileDrawer}
      </div>
    </>
  )
}

interface FilterSectionProps {
  title: string
  section: string
  expanded: boolean
  onToggle: () => void
  options: string[]
  selectedValue?: string
  onSelect: (value: string) => void
}

const FilterSection: React.FC<FilterSectionProps> = ({
  title,
  expanded,
  onToggle,
  options,
  selectedValue,
  onSelect,
}) => (
  <div className="border-b border-slate-100">
    <button
      onClick={onToggle}
      className="w-full px-4 py-3 flex items-center justify-between hover:bg-slate-50 transition-colors text-sm font-medium text-slate-900"
      aria-expanded={expanded}
    >
      <span>{title}</span>
      <FiChevronDown size={16} className={`transition-transform ${expanded ? 'rotate-180' : ''}`} />
    </button>
    {expanded && (
      <div className="px-2 py-2 bg-slate-50 space-y-1">
        {options.map((option) => (
          <button
            key={option}
            onClick={() => onSelect(option)}
            className={`w-full text-left px-3 py-2 rounded text-sm transition-all ${
              selectedValue === option.toLowerCase().replace(/\s+/g, '_') || (option.startsWith('All') && !selectedValue)
                ? 'bg-blue-100 text-blue-700 font-medium'
                : 'text-slate-700 hover:bg-slate-200'
            }`}
          >
            {option}
          </button>
        ))}
      </div>
    )}
  </div>
)

export const UnderwritingFilters = memo(UnderwritingFiltersComponent)



================================================================================
FILE: src/constants/filterOptions.ts
================================================================================
/**
 * Shared filter options for underwriting filters and metadata input
 * Consolidates filter choices to avoid duplication
 */

export const FILTER_OPTIONS = {
  brokers: ['Marsh', 'Aon', 'Willis Towers Watson', 'Gallagher', 'Brown & Brown', 'Other'],
  lobs: ['commercial_general_liability', 'property', 'workers_compensation', 'commercial_auto', 'umbrella', 'cyber', 'management_liability'],
  businessTypes: ['new_business', 'renewal', 'modification', 'cancellation'],
  riskCategories: ['manufacturing', 'retail', 'healthcare', 'technology', 'construction', 'professional_services', 'hospitality', 'education'],
  underwritingStatus: ['pending', 'approved', 'declined', 'referred'],
}

/**
 * Display labels for filter options (for UI rendering)
 */
export const FILTER_LABELS: Record<string, Record<string, string>> = {
  lobs: {
    commercial_general_liability: 'Commercial General Liability',
    property: 'Property',
    workers_compensation: 'Workers Compensation',
    commercial_auto: 'Commercial Auto',
    umbrella: 'Umbrella',
    cyber: 'Cyber',
    management_liability: 'Management Liability',
  },
  businessTypes: {
    new_business: 'New Business',
    renewal: 'Renewal',
    modification: 'Modification',
    cancellation: 'Cancellation',
  },
  riskCategories: {
    manufacturing: 'Manufacturing',
    retail: 'Retail',
    healthcare: 'Healthcare',
    technology: 'Technology',
    construction: 'Construction',
    professional_services: 'Professional Services',
    hospitality: 'Hospitality',
    education: 'Education',
  },
  underwritingStatus: {
    pending: 'Pending',
    approved: 'Approved',
    declined: 'Declined',
    referred: 'Referred',
  },
}

/**
 * Helper function to get display label for a filter value
 */
export const getFilterLabel = (category: string, value: string): string => {
  return FILTER_LABELS[category]?.[value] || value.replace(/_/g, ' ').charAt(0).toUpperCase() + value.slice(1)
}



================================================================================
FILE: src/constants/index.ts
================================================================================
/**
 * Application-wide constants
 * Centralized configuration for easy maintenance and AI agent comprehension
 */

// ============================================================================
// UI CONSTANTS
// ============================================================================

export const UI = {
  // Animation delays (ms)
  ANIMATION_DELAY_FAST: 150,
  ANIMATION_DELAY_MEDIUM: 300,
  ANIMATION_DELAY_SLOW: 600,

  // Sidebar
  SIDEBAR_WIDTH: 280,
  SIDEBAR_ANIMATION_DURATION: 300,

  // Chat input
  MAX_MESSAGE_LENGTH: 4000,
  MESSAGE_INPUT_MAX_HEIGHT: 120,
  MESSAGE_INPUT_ROWS: 1,

  // Chat messages
  MAX_MESSAGES_TO_SEND_TO_API: 20,
  MESSAGE_SCROLL_BEHAVIOR: 'smooth' as const,

  // Timeouts
  COPY_FEEDBACK_DURATION: 2000,
  TOAST_DURATION: 3000,
  DEBOUNCE_DELAY: 300,
} as const

// ============================================================================
// API CONSTANTS
// ============================================================================

export const API = {
  // OpenAI
  MODEL: 'gpt-4o-mini',
  TEMPERATURE: 0.7,
  MAX_TOKENS: 1000,

  // Retry logic
  MAX_RETRIES: 3,
  RETRY_DELAY_MS: 1000,
  BACKOFF_MULTIPLIER: 2,
  REQUEST_TIMEOUT_MS: 30000,

  // Rate limiting
  MIN_REQUEST_INTERVAL_MS: 500,
} as const

// ============================================================================
// FIRESTORE CONSTANTS
// ============================================================================

export const FIRESTORE = {
  COLLECTIONS: {
    CONVERSATIONS: 'conversations',
    MESSAGES: 'messages',
    VOICE_NOTES: 'voiceNotes',
  },
  BATCH_SIZE: 50,
  QUERY_LIMIT: 100,
} as const

// ============================================================================
// ROUTES
// ============================================================================

export const ROUTES = {
  HOME: '/',
  CHAT: '/chat',
  HISTORY: '/history',
  UPLOAD: '/upload',
} as const

// ============================================================================
// ERROR MESSAGES
// ============================================================================

export const ERROR_MESSAGES = {
  API_KEY_MISSING: 'âš ï¸ OpenAI API key not configured. Please set VITE_OPENAI_API_KEY in .env.local and restart.',
  NO_RESPONSE_CONTENT: 'No response content from OpenAI API',
  EMPTY_RESPONSE: 'Empty response from AI provider',
  FAILED_TO_CREATE_CONVERSATION: 'Failed to create conversation',
  FAILED_TO_LOAD_CONVERSATIONS: 'Failed to load conversations',
  FAILED_TO_LOAD_MESSAGES: 'Failed to load messages',
  FAILED_TO_SEND_MESSAGE: 'Failed to send message',
  INVALID_RESPONSE: 'Invalid response from API',
  NETWORK_ERROR: 'Network error. Please check your connection.',
  TIMEOUT_ERROR: 'Request timed out. Please try again.',
} as const

// ============================================================================
// DATE GROUPING
// ============================================================================

export const DATE_GROUPS = {
  TODAY: 'Today',
  YESTERDAY: 'Yesterday',
  THIS_WEEK: 'This Week',
  THIS_MONTH: 'This Month',
  OLDER: 'Older',
} as const

// ============================================================================
// CONVERSATION DEFAULTS
// ============================================================================

export const CONVERSATION = {
  DEFAULT_TITLE_PREFIX: 'Chat',
  EMPTY_STATE_MESSAGE: 'Start a new conversation to begin',
} as const



================================================================================
FILE: src/firebase.ts
================================================================================
// Import the functions you need from the SDKs you need
import { initializeApp } from 'firebase/app'
import { getAnalytics } from 'firebase/analytics'
import { getFirestore } from 'firebase/firestore'
import { getStorage } from 'firebase/storage'

/**
 * Firebase configuration loaded from environment variables
 * Supports both hardcoded defaults (for generic-voice project) and environment-based config
 *
 * Environment variables (optional):
 * - VITE_FIREBASE_API_KEY
 * - VITE_FIREBASE_AUTH_DOMAIN
 * - VITE_FIREBASE_PROJECT_ID
 * - VITE_FIREBASE_STORAGE_BUCKET
 * - VITE_FIREBASE_MESSAGING_SENDER_ID
 * - VITE_FIREBASE_APP_ID
 * - VITE_FIREBASE_MEASUREMENT_ID
 */
function getFirebaseConfig() {
  // Default configuration for generic-voice project
  const defaultConfig = {
    apiKey: 'AIzaSyArd37qujqzU0Er5GJ6RVcUiFndTA5Dbvk',
    authDomain: 'generic-voice.firebaseapp.com',
    projectId: 'generic-voice',
    storageBucket: 'generic-voice.firebasestorage.app',
    messagingSenderId: '297339398874',
    appId: '1:297339398874:web:e6a3d9089ad4c2314913e3',
    measurementId: 'G-TXQ7DFG0XK',
  }

  // Allow environment variable overrides
  const firebaseConfig = {
    apiKey: import.meta.env.VITE_FIREBASE_API_KEY || defaultConfig.apiKey,
    authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || defaultConfig.authDomain,
    projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || defaultConfig.projectId,
    storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || defaultConfig.storageBucket,
    messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || defaultConfig.messagingSenderId,
    appId: import.meta.env.VITE_FIREBASE_APP_ID || defaultConfig.appId,
    measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID || defaultConfig.measurementId,
  }

  // Validate required fields
  if (!firebaseConfig.projectId) {
    throw new Error('Firebase projectId is required. Set VITE_FIREBASE_PROJECT_ID or use default configuration.')
  }

  return firebaseConfig
}

const firebaseConfig = getFirebaseConfig()

// Initialize Firebase
const app = initializeApp(firebaseConfig)

// Initialize Analytics safely (may not be available in all environments)
let analytics
try {
  if (typeof window !== 'undefined' && firebaseConfig.measurementId) {
    analytics = getAnalytics(app)
  }
} catch (error) {
  console.warn('Analytics initialization failed:', error)
}

const db = getFirestore(app)
const storage = getStorage(app)

export { app, analytics, db, storage }



================================================================================
FILE: src/hooks/useAsync.ts
================================================================================
/**
 * Custom hook for handling async operations
 * Manages loading, error, and data states for async functions
 */

import { useState, useCallback, useEffect, useRef } from 'react'

interface UseAsyncState<T> {
  data: T | null
  loading: boolean
  error: Error | null
}

interface UseAsyncOptions<T> {
  immediate?: boolean
  onSuccess?: (data: T) => void
  onError?: (error: Error) => void
}

/**
 * Hook for managing async operations
 * @param asyncFunction - Async function to execute
 * @param options - Configuration options
 * @returns State and execute function
 */
export function useAsync<T>(
  asyncFunction: () => Promise<T>,
  options: UseAsyncOptions<T> = {}
) {
  const { immediate = false, onSuccess, onError } = options

  const [state, setState] = useState<UseAsyncState<T>>({
    data: null,
    loading: false,
    error: null,
  })

  const execute = useCallback(async () => {
    setState({ data: null, loading: true, error: null })
    try {
      const result = await asyncFunction()
      setState({ data: result, loading: false, error: null })
      onSuccess?.(result)
      return result
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error))
      setState({ data: null, loading: false, error: err })
      onError?.(err)
      throw err
    }
  }, [asyncFunction, onSuccess, onError])

  const hasExecuted = useRef(false)

  useEffect(() => {
    if (immediate && !hasExecuted.current) {
      hasExecuted.current = true
      // Schedule execution asynchronously to avoid setState in effect
      const timeoutId = setTimeout(() => {
        execute()
      }, 0)
      return () => clearTimeout(timeoutId)
    }
  }, [execute, immediate])

  return {
    ...state,
    execute,
  }
}

/**
 * Hook for managing async operations with dependencies
 * @param asyncFunction - Async function to execute
 * @returns State object
 */
export function useAsyncEffect<T>(
  asyncFunction: () => Promise<T>
) {
  const [state, setState] = useState<UseAsyncState<T>>({
    data: null,
    loading: true,
    error: null,
  })

  const executeAsync = useCallback(async () => {
    try {
      const result = await asyncFunction()
      setState({ data: result, loading: false, error: null })
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error))
      setState({ data: null, loading: false, error: err })
    }
  }, [asyncFunction])

  useEffect(() => {
    let isMounted = true

    const execute = async () => {
      if (isMounted) {
        await executeAsync()
      }
    }

    execute()

    return () => {
      isMounted = false
    }
  }, [executeAsync])

  return state
}



================================================================================
FILE: src/hooks/useChatOperations.ts
================================================================================
import { useCallback } from 'react'
import { chatService } from '../services/chatService'
import { logger } from '../services/logger'
import { isOpenAIConfigured, getApiKeyErrorMessage } from '../services/config'
import type { Conversation, ChatMessage } from '../types'

interface UseChatOperationsProps {
  setConversations: (convs: Conversation[]) => void
  setCurrentConversationId: (id: string | null) => void
  setMessages: (msgs: ChatMessage[]) => void
  setIsApiKeyMissing: (missing: boolean) => void
  setApiError: (error: string | undefined) => void
}

export const useChatOperations = ({
  setConversations,
  setCurrentConversationId,
  setMessages,
  setIsApiKeyMissing,
  setApiError,
}: UseChatOperationsProps) => {
  const loadConversations = useCallback(async () => {
    try {
      const convs = await chatService.getAllConversations()
      setConversations(convs)
      logger.debug('Conversations loaded successfully', { count: convs.length })
    } catch (error) {
      logger.error('Failed to load conversations', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to load conversations'
      setApiError(`Error loading conversations: ${errorMsg}`)
    }
  }, [setConversations, setApiError])

  const loadMessages = useCallback(async (conversationId: string) => {
    if (!conversationId) {
      logger.warn('loadMessages called with empty conversationId')
      return
    }

    try {
      logger.debug('Loading messages for conversation', { conversationId })
      const msgs = await chatService.getConversationMessages(conversationId)
      logger.debug('Messages loaded', { count: msgs.length })
      setMessages(msgs)
    } catch (error) {
      logger.error('Failed to load messages', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to load messages'
      setApiError(`Error loading messages: ${errorMsg}`)
    }
  }, [setMessages, setApiError])

  const handleNewConversation = useCallback(async () => {
    try {
      const title = `Chat ${new Date().toLocaleDateString()}`
      logger.info('Creating new conversation', { title })
      const conversationId = await chatService.createConversation(title)
      setCurrentConversationId(conversationId)
      setMessages([])
      await loadConversations()
      logger.info('New conversation created successfully', { conversationId })
    } catch (error) {
      logger.error('Failed to create conversation', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to create conversation'
      setApiError(`Error creating conversation: ${errorMsg}`)
    }
  }, [loadConversations, setCurrentConversationId, setMessages, setApiError])

  const handleSelectConversation = useCallback((conversationId: string) => {
    setCurrentConversationId(conversationId)
  }, [setCurrentConversationId])

  const initializeChat = useCallback(async () => {
    try {
      logger.info('Initializing chat')

      // Check if OpenAI API key is configured
      if (!isOpenAIConfigured()) {
        logger.warn('OpenAI API key is not configured')
        setIsApiKeyMissing(true)
        setApiError(getApiKeyErrorMessage())
        return
      }

      const convs = await chatService.getAllConversations()
      setConversations(convs)
      logger.debug('Chat initialized', { conversationCount: convs.length })

      // Create initial conversation if none exist
      if (convs.length === 0) {
        const title = `Chat ${new Date().toLocaleDateString()}`
        logger.info('Creating initial conversation', { title })
        const conversationId = await chatService.createConversation(title)
        setCurrentConversationId(conversationId)
        setMessages([])
        logger.info('Initial conversation created', { conversationId })
      }
    } catch (error) {
      logger.error('Failed to initialize chat', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to initialize chat'
      setApiError(`Error initializing chat: ${errorMsg}`)
    }
  }, [setConversations, setCurrentConversationId, setMessages, setIsApiKeyMissing, setApiError])

  return {
    loadConversations,
    loadMessages,
    handleNewConversation,
    handleSelectConversation,
    initializeChat,
  }
}



================================================================================
FILE: src/hooks/useChatState.ts
================================================================================
import { useState, useCallback } from 'react'
import type { ChatMessage, Conversation } from '../types'

/**
 * Custom hook to manage chat state
 * Reduces complexity in MainChatPage by encapsulating related state
 */
export const useChatState = () => {
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null)
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [inputValue, setInputValue] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [apiError, setApiError] = useState<string>()
  const [isApiKeyMissing, setIsApiKeyMissing] = useState(false)

  const resetInput = useCallback(() => {
    setInputValue('')
  }, [])

  const clearError = useCallback(() => {
    setApiError(undefined)
  }, [])

  const toggleSidebar = useCallback(() => {
    setSidebarOpen(prev => !prev)
  }, [])

  return {
    // State
    conversations,
    currentConversationId,
    messages,
    inputValue,
    isLoading,
    sidebarOpen,
    apiError,
    isApiKeyMissing,
    // Setters
    setConversations,
    setCurrentConversationId,
    setMessages,
    setInputValue,
    setIsLoading,
    setSidebarOpen,
    setApiError,
    setIsApiKeyMissing,
    // Helpers
    resetInput,
    clearError,
    toggleSidebar,
  }
}



================================================================================
FILE: src/hooks/useDebounce.ts
================================================================================
/**
 * Custom hook for debouncing values and functions
 * Useful for search inputs, auto-save, and other delayed operations
 */

import { useState, useEffect, useCallback, useRef } from 'react'

/**
 * Hook for debouncing a value
 * @param value - Value to debounce
 * @param delay - Debounce delay in milliseconds
 * @returns Debounced value
 */
export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => clearTimeout(handler)
  }, [value, delay])

  return debouncedValue
}

/**
 * Hook for debouncing a callback function
 * @param callback - Callback to debounce
 * @param delay - Debounce delay in milliseconds
 * @returns Debounced callback
 */
export function useDebouncedCallback<T extends (...args: unknown[]) => void>(
  callback: T,
  delay: number = 300
): (...args: Parameters<T>) => void {
  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined)

  const debouncedCallback = useCallback(
    (...args: Parameters<T>) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }

      timeoutRef.current = setTimeout(() => {
        callback(...args)
      }, delay)
    },
    [callback, delay]
  )

  return debouncedCallback
}

/**
 * Hook for throttling a callback function
 * @param callback - Callback to throttle
 * @param delay - Throttle delay in milliseconds
 * @returns Throttled callback
 */
export function useThrottledCallback<T extends (...args: unknown[]) => void>(
  callback: T,
  delay: number = 300
): (...args: Parameters<T>) => void {
  const lastRunRef = useRef<number>(0)

  const throttledCallback = useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now()
      if (now - lastRunRef.current >= delay) {
        lastRunRef.current = now
        callback(...args)
      }
    },
    [callback, delay]
  )

  return throttledCallback
}



================================================================================
FILE: src/hooks/useLocalStorage.ts
================================================================================
/**
 * Custom hook for managing localStorage
 * Provides type-safe access to localStorage with automatic serialization
 */

import { useState, useCallback } from 'react'

/**
 * Hook for managing a value in localStorage
 * @param key - Storage key
 * @param initialValue - Initial value if key doesn't exist
 * @returns Tuple of [value, setValue, removeValue]
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void, () => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })

  const setValue = useCallback(
    (value: T | ((val: T) => T)) => {
      try {
        const valueToStore = value instanceof Function ? value(storedValue) : value
        setStoredValue(valueToStore)
        window.localStorage.setItem(key, JSON.stringify(valueToStore))
      } catch (error) {
        console.error(`Error setting localStorage key "${key}":`, error)
      }
    },
    [key, storedValue]
  )

  const removeValue = useCallback(() => {
    try {
      window.localStorage.removeItem(key)
      setStoredValue(initialValue)
    } catch (error) {
      console.error(`Error removing localStorage key "${key}":`, error)
    }
  }, [key, initialValue])

  return [storedValue, setValue, removeValue]
}

/**
 * Hook for managing multiple localStorage values
 * @param keys - Array of storage keys
 * @param initialValues - Initial values for each key
 * @returns Object with values and setters
 */
export function useLocalStorageMultiple<T extends Record<string, unknown>>(
  keys: (keyof T)[],
  initialValues: T
): {
  values: T
  setValues: (updates: Partial<T>) => void
  clearAll: () => void
} {
  const [values, setValues] = useState<T>(() => {
    const stored: Partial<T> = {}
    keys.forEach(key => {
      try {
        const item = window.localStorage.getItem(String(key))
        if (item) {
          stored[key] = JSON.parse(item)
        } else {
          stored[key] = initialValues[key]
        }
      } catch (error) {
        console.error(`Error reading localStorage key "${String(key)}":`, error)
        stored[key] = initialValues[key]
      }
    })
    return stored as T
  })

  const updateValues = useCallback(
    (updates: Partial<T>) => {
      const newValues = { ...values, ...updates }
      setValues(newValues)
      Object.entries(updates).forEach(([key, value]) => {
        try {
          window.localStorage.setItem(key, JSON.stringify(value))
        } catch (error) {
          console.error(`Error setting localStorage key "${key}":`, error)
        }
      })
    },
    [values]
  )

  const clearAll = useCallback(() => {
    keys.forEach(key => {
      try {
        window.localStorage.removeItem(String(key))
      } catch (error) {
        console.error(`Error removing localStorage key "${String(key)}":`, error)
      }
    })
    setValues(initialValues)
  }, [keys, initialValues])

  return {
    values,
    setValues: updateValues,
    clearAll,
  }
}



================================================================================
FILE: src/hooks/useTheme.ts
================================================================================
/**
 * Hook for managing theme - Light theme only
 * Always returns 'light' theme for consistent light-themed UI
 */

import { useCallback } from 'react'

export type Theme = 'light'

/**
 * Hook to manage theme preference
 * @returns Current theme as 'light' and no-op setTheme function
 */
export function useTheme() {
  const theme: Theme = 'light'
  const effectiveTheme: 'light' | 'dark' = 'light'

  const setTheme = useCallback(() => {
    // No-op: theme is always light
  }, [])

  return {
    theme,
    effectiveTheme,
    setTheme,
  }
}



================================================================================
FILE: src/hooks/useUnderwritingFilters.ts
================================================================================
import { useState, useCallback, useMemo } from 'react'
import type { Conversation, ConversationMetadata } from '../types'

/**
 * Hook for managing underwriting filters and applying them to conversations
 */
export function useUnderwritingFilters() {
  const [filters, setFilters] = useState<Partial<ConversationMetadata>>({})

  const updateFilters = useCallback((newFilters: Partial<ConversationMetadata>) => {
    setFilters(newFilters)
  }, [])

  const clearFilters = useCallback(() => {
    setFilters({})
  }, [])

  const applyFilters = useCallback((conversations: Conversation[]): Conversation[] => {
    if (Object.keys(filters).length === 0) {
      return conversations
    }

    return conversations.filter(conv => {
      const metadata = conv.metadata || {}

      // Check each active filter
      for (const [key, filterValue] of Object.entries(filters)) {
        const metadataValue = metadata[key as keyof ConversationMetadata]

        if (!metadataValue) {
          return false
        }

        // Handle string comparison
        if (typeof filterValue === 'string' && typeof metadataValue === 'string') {
          if (metadataValue.toLowerCase() !== filterValue.toLowerCase()) {
            return false
          }
        }
        // Handle array comparison
        else if (Array.isArray(filterValue) && Array.isArray(metadataValue)) {
          if (!filterValue.some(v => metadataValue.includes(v))) {
            return false
          }
        }
        // Handle other types
        else if (metadataValue !== filterValue) {
          return false
        }
      }

      return true
    })
  }, [filters])

  const filteredConversations = useCallback((conversations: Conversation[]): Conversation[] => {
    return applyFilters(conversations)
  }, [applyFilters])

  const hasActiveFilters = useMemo(() => Object.keys(filters).length > 0, [filters])

  return {
    filters,
    updateFilters,
    clearFilters,
    applyFilters: filteredConversations,
    hasActiveFilters,
  }
}



================================================================================
FILE: src/hooks/useVoiceNotes.ts
================================================================================
/**
 * Hook for managing voice notes with real-time updates
 * Provides filtering and search capabilities
 */

import { useState, useEffect, useCallback } from 'react'
import { voiceNoteService } from '../services/voiceNoteService'
import { logger } from '../services/logger'
import type { VoiceNote, VoiceNoteStatus } from '../types'

export interface UseVoiceNotesOptions {
  statusFilter?: VoiceNoteStatus | 'all'
  searchTerm?: string
}

export interface UseVoiceNotesResult {
  voiceNotes: VoiceNote[]
  isLoading: boolean
  error: Error | null
  refetch: () => Promise<void>
}

/**
 * Hook to fetch and manage voice notes
 * @param options - Optional filtering and search options
 * @returns Voice notes data, loading state, error, and refetch function
 */
export function useVoiceNotes(options?: UseVoiceNotesOptions): UseVoiceNotesResult {
  const [voiceNotes, setVoiceNotes] = useState<VoiceNote[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const fetchVoiceNotes = useCallback(async () => {
    try {
      setIsLoading(true)
      setError(null)
      const notes = await voiceNoteService.getAllVoiceNotes()

      // Apply filters
      let filtered = notes

      if (options?.statusFilter && options.statusFilter !== 'all') {
        filtered = filtered.filter(note => note.status === options.statusFilter)
      }

      if (options?.searchTerm) {
        const term = options.searchTerm.toLowerCase()
        filtered = filtered.filter(note =>
          note.fileName.toLowerCase().includes(term) ||
          note.transcriptSummary?.toLowerCase().includes(term)
        )
      }

      // Sort by updatedAt descending
      filtered.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())

      setVoiceNotes(filtered)
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      logger.error('Error fetching voice notes', error)
      setError(error)
    } finally {
      setIsLoading(false)
    }
  }, [options?.statusFilter, options?.searchTerm])

  useEffect(() => {
    fetchVoiceNotes()
  }, [fetchVoiceNotes])

  return {
    voiceNotes,
    isLoading,
    error,
    refetch: fetchVoiceNotes,
  }
}



================================================================================
FILE: src/main.tsx
================================================================================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import './firebase'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


================================================================================
FILE: src/pages/AudioUploadPage.tsx
================================================================================
import React, { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { FiArrowLeft, FiUploadCloud, FiCheck, FiMic, FiAlertCircle } from 'react-icons/fi'
import { voiceNoteService } from '../services/voiceNoteService'
import { logger } from '../services/logger'

const AudioUploadPage: React.FC = () => {
  const navigate = useNavigate()
  const [isDragging, setIsDragging] = useState(false)
  const [fileName, setFileName] = useState<string>()
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState(0)
  const [uploadError, setUploadError] = useState<string>()
  const [uploadedVoiceNoteId, setUploadedVoiceNoteId] = useState<string>()

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(true)
  }

  const handleDragLeave = () => {
    setIsDragging(false)
  }

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)
    const files = e.dataTransfer.files
    if (files.length > 0) {
      handleFileSelect(files[0])
    }
  }

  const validateFile = (file: File): string | null => {
    // Validate file type
    const validAudioTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/ogg', 'audio/webm', 'audio/flac']
    if (!file.type.startsWith('audio/') && !validAudioTypes.includes(file.type)) {
      return 'Please select a valid audio file (MP3, WAV, M4A, OGG, WebM, FLAC)'
    }

    // Validate file size (max 100MB)
    const maxSize = 100 * 1024 * 1024
    if (file.size > maxSize) {
      return `File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds 100MB limit. Please select a smaller file.`
    }

    // Validate minimum file size (at least 1KB)
    if (file.size < 1024) {
      return 'File is too small. Please select a valid audio file.'
    }

    return null
  }

  const handleFileSelect = (file: File) => {
    setUploadError(undefined)

    // Validate file
    const validationError = validateFile(file)
    if (validationError) {
      setUploadError(validationError)
      logger.warn('File validation failed', { fileName: file.name, error: validationError })
      return
    }

    setFileName(file.name)
    performUpload(file)
  }

  const performUpload = async (file: File) => {
    setIsUploading(true)
    setUploadProgress(0)
    setUploadError(undefined)

    try {
      logger.info('Starting real Firebase upload', { fileName: file.name })

      const result = await voiceNoteService.uploadAudioFile(file, (progress) => {
        setUploadProgress(Math.round(progress.progress))
      })

      logger.info('Upload completed successfully', { voiceNoteId: result.voiceNote.id })
      setUploadedVoiceNoteId(result.voiceNote.id)
      setUploadProgress(100)

      // Navigate to chat after a short delay, passing the voice note ID
      setTimeout(() => {
        navigate('/chat', { state: { voiceNoteId: result.voiceNote.id } })
      }, 1500)
    } catch (error) {
      logger.error('Upload failed', error)
      const errorMsg = error instanceof Error ? error.message : 'Upload failed. Please try again.'
      setUploadError(errorMsg)
      setIsUploading(false)
      setUploadProgress(0)
    }
  }

  return (
    <div className="h-screen flex flex-col bg-white">
      {/* Header with improved visual hierarchy */}
      <div className="border-b border-slate-200 px-4 sm:px-6 py-4 sm:py-5 bg-gradient-to-r from-white to-slate-50 shadow-sm hover:shadow-md transition-shadow duration-200">
        <div className="flex items-center gap-3 sm:gap-4">
          <button
            onClick={() => navigate('/chat')}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all duration-200 text-slate-700 hover:text-slate-900 hover:scale-110 active:scale-95 flex-shrink-0 focus-visible-ring"
            aria-label="Go back to chat"
          >
            <FiArrowLeft size={20} />
          </button>
          <div className="flex-1">
            <h1 className="text-xl sm:text-2xl font-bold text-slate-900 flex items-center gap-2 min-w-0">
              <FiMic size={24} className="text-blue-600 flex-shrink-0" aria-hidden="true" />
              <span className="truncate">Upload Audio</span>
            </h1>
            <p className="text-xs sm:text-sm text-slate-500 mt-1">Upload voice notes for AI analysis</p>
          </div>
        </div>
      </div>

      {/* Error Banner */}
      {uploadError && (
        <div className="bg-red-50 border-b border-red-200 px-4 sm:px-6 py-4 sm:py-5 flex items-start gap-3">
          <FiAlertCircle className="text-red-600 flex-shrink-0 mt-0.5" size={20} aria-hidden="true" />
          <div className="flex-1 min-w-0">
            <p className="text-sm text-red-800 font-medium break-words">{uploadError}</p>
          </div>
          <button
            onClick={() => setUploadError(undefined)}
            className="text-red-600 hover:text-red-700 flex-shrink-0 font-bold"
            aria-label="Dismiss error"
          >
            âœ•
          </button>
        </div>
      )}

      {/* Content */}
      <div className="flex-1 flex items-center justify-center p-4 sm:p-8 bg-gradient-to-b from-white to-slate-50">
        <div className="max-w-2xl w-full">
          <div
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            className={`border-2 border-dashed rounded-3xl p-8 sm:p-16 text-center transition-all duration-300 ${
              isDragging
                ? 'border-blue-500 bg-blue-50 shadow-2xl shadow-blue-500/40 scale-105 -translate-y-2'
                : 'border-slate-300 bg-white hover:border-blue-500 hover:shadow-lg hover:shadow-blue-500/20 hover:scale-105 hover:-translate-y-1'
            }`}
            role="region"
            aria-label="Audio upload area"
          >
            {uploadProgress === 100 && uploadedVoiceNoteId ? (
              <div className="space-y-6 animate-fade-in">
                <div className="w-20 h-20 mx-auto bg-gradient-to-br from-green-400 to-green-600 rounded-full flex items-center justify-center shadow-lg hover:scale-110 transition-all duration-300 animate-pulse-soft flex-shrink-0">
                  <FiCheck size={40} className="text-white" aria-hidden="true" />
                </div>
                <div>
                  <h3 className="text-2xl sm:text-3xl font-bold text-slate-900 mb-3 flex items-center gap-2 justify-center">
                    <FiCheck size={24} className="text-green-600 flex-shrink-0" aria-hidden="true" />
                    Upload Complete!
                  </h3>
                  <p className="text-slate-600 text-lg font-semibold truncate">{fileName}</p>
                  <p className="text-slate-500 text-base mt-4">Redirecting to chat in a moment...</p>
                </div>
                <div className="flex flex-col sm:flex-row gap-3 justify-center pt-4">
                  <button
                    onClick={() => navigate('/chat', { state: { voiceNoteId: uploadedVoiceNoteId } })}
                    className="px-8 py-4 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 text-white rounded-xl transition-all duration-200 font-semibold shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 text-base"
                  >
                    Go to Chat Now
                  </button>
                </div>
              </div>
            ) : isUploading ? (
              <div className="space-y-6 animate-fade-in">
                <div className="w-16 h-16 mx-auto bg-gradient-to-br from-blue-100 to-blue-200 rounded-full flex items-center justify-center shadow-md flex-shrink-0">
                  <div className="animate-spin">
                    <FiUploadCloud size={32} className="text-blue-600" aria-hidden="true" />
                  </div>
                </div>
                <div>
                  <h3 className="text-xl sm:text-2xl font-bold text-slate-900 mb-4 flex items-center gap-2 justify-center">
                    <FiUploadCloud size={20} className="text-blue-600 animate-bounce flex-shrink-0" aria-hidden="true" />
                    Uploading...
                  </h3>
                  <div className="w-full bg-slate-200 rounded-full h-2.5 overflow-hidden shadow-sm">
                    <div
                      className="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
                      style={{ width: `${uploadProgress}%` }}
                      role="progressbar"
                      aria-valuenow={uploadProgress}
                      aria-valuemin={0}
                      aria-valuemax={100}
                    />
                  </div>
                  <p className="text-base text-slate-600 font-semibold mt-3">{uploadProgress}%</p>
                </div>
              </div>
            ) : (
              <div className="space-y-6 animate-fade-in">
                <div className="w-16 h-16 mx-auto bg-gradient-to-br from-blue-100 to-cyan-100 rounded-full flex items-center justify-center shadow-md hover:scale-110 transition-all duration-300 animate-pulse-soft flex-shrink-0">
                  <FiUploadCloud size={32} className="text-blue-600" aria-hidden="true" />
                </div>
                <div>
                  <h3 className="text-xl sm:text-2xl font-bold text-slate-900 mb-3">Upload Audio File</h3>
                  <p className="text-slate-600 text-base mb-4 font-medium">Drag and drop your audio file here, or click to select</p>
                  <p className="text-slate-500 text-sm">Supported formats: MP3, WAV, M4A, OGG (Max 100MB)</p>
                </div>
                <input
                  type="file"
                  accept="audio/*"
                  onChange={(e) => e.target.files && handleFileSelect(e.target.files[0])}
                  className="hidden"
                  id="audio-input"
                  aria-label="Select audio file"
                />
                <label
                  htmlFor="audio-input"
                  className="inline-block px-8 py-3 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 text-white rounded-xl transition-all duration-200 cursor-pointer font-semibold shadow-lg hover:shadow-xl hover:scale-105 active:scale-95 text-sm focus-visible-ring"
                >
                  Select File
                </label>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export { AudioUploadPage }



================================================================================
FILE: src/pages/ChatHistoryPage.tsx
================================================================================
import React, { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { chatService } from '../services/chatService'
import { logger } from '../services/logger'
import type { Conversation } from '../types'
import { FiArrowLeft, FiTrash2, FiMessageSquare, FiClock, FiSearch, FiBook } from 'react-icons/fi'

const ChatHistoryPage: React.FC = () => {
  const navigate = useNavigate()
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [searchQuery, setSearchQuery] = useState('')

  useEffect(() => {
    const loadConversations = async () => {
      try {
        const convs = await chatService.getAllConversations()
        setConversations(convs)
      } catch (error) {
        logger.error('Failed to load conversations', error)
      } finally {
        setIsLoading(false)
      }
    }
    loadConversations()
  }, [])

  const handleSelectConversation = (id: string) => {
    navigate('/chat', { state: { conversationId: id } })
  }

  const handleDeleteConversation = async (id: string, e: React.MouseEvent) => {
    e.stopPropagation()
    const conversation = conversations.find(c => c.id === id)
    const title = conversation?.title || 'this conversation'

    if (confirm(`Are you sure you want to delete "${title}"? This action cannot be undone.`)) {
      try {
        await chatService.deleteConversation(id)
        setConversations(conversations.filter(c => c.id !== id))
        logger.info('Conversation deleted successfully', { id })
      } catch (error) {
        logger.error('Failed to delete conversation', error)
        const errorMsg = error instanceof Error ? error.message : 'Failed to delete conversation'
        alert(`Error: ${errorMsg}`)
      }
    }
  }

  const formatDate = (dateString: string | Date) => {
    const date = typeof dateString === 'string' ? new Date(dateString) : dateString
    const today = new Date()
    const yesterday = new Date(today)
    yesterday.setDate(yesterday.getDate() - 1)

    if (date.toDateString() === today.toDateString()) {
      return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })
    } else if (date.toDateString() === yesterday.toDateString()) {
      return 'Yesterday'
    } else {
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
    }
  }

  const filteredConversations = conversations.filter(conv =>
    conv.title.toLowerCase().includes(searchQuery.toLowerCase())
  )

  return (
    <div className="h-screen flex flex-col bg-gradient-to-b from-white to-slate-50">
      {/* Header with improved visual hierarchy */}
      <div className="border-b border-slate-200 px-4 sm:px-6 py-4 sm:py-5 bg-gradient-to-r from-white to-slate-50 shadow-sm hover:shadow-md transition-shadow duration-200">
        <div className="flex items-center gap-3 sm:gap-4 mb-4 sm:mb-5">
          <button
            onClick={() => navigate('/chat')}
            className="p-2 hover:bg-slate-100 rounded-lg transition-all duration-200 text-slate-700 hover:text-slate-900 hover:scale-110 active:scale-95 flex-shrink-0 focus-visible-ring"
            aria-label="Go back to chat"
          >
            <FiArrowLeft size={20} />
          </button>
          <div className="flex-1">
            <h1 className="text-xl sm:text-2xl font-bold text-slate-900 flex items-center gap-2 min-w-0">
              <FiBook size={24} className="text-blue-600 flex-shrink-0" aria-hidden="true" />
              <span className="truncate">Chat History</span>
            </h1>
            <p className="text-xs sm:text-sm text-slate-500 mt-1">{filteredConversations.length} conversation{filteredConversations.length !== 1 ? 's' : ''}</p>
          </div>
        </div>
        {/* Enhanced Search Bar */}
        <div className="relative">
          <FiSearch className="absolute left-3 sm:left-4 top-1/2 transform -translate-y-1/2 text-slate-400 flex-shrink-0" size={16} aria-hidden="true" />
          <input
            type="text"
            placeholder="Search conversations..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-10 sm:pl-11 pr-3 sm:pr-4 py-2.5 bg-white border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-xs sm:text-sm text-slate-900 placeholder-slate-500 transition-all duration-200 hover:border-slate-400 shadow-sm hover:shadow-md"
            aria-label="Search conversations"
          />
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto p-4 sm:p-8 bg-gradient-to-b from-white to-slate-50">
        <div className="max-w-5xl mx-auto">
          {isLoading ? (
            <div className="space-y-3">
              {[...Array(3)].map((_, i) => (
                <div
                  key={i}
                  className="bg-white rounded-xl p-4 sm:p-5 border border-slate-200 animate-pulse"
                >
                  <div className="flex items-start justify-between gap-4">
                    <div className="flex-1 min-w-0 space-y-3">
                      <div className="h-5 bg-slate-200 rounded-lg w-3/4" />
                      <div className="flex items-center gap-3">
                        <div className="h-4 bg-slate-200 rounded w-24" />
                        <div className="w-1 h-1 bg-slate-300 rounded-full" />
                        <div className="h-4 bg-slate-200 rounded w-32" />
                      </div>
                    </div>
                    <div className="h-8 w-8 bg-slate-200 rounded flex-shrink-0" />
                  </div>
                </div>
              ))}
            </div>
          ) : filteredConversations.length === 0 ? (
            <div className="flex items-center justify-center h-64">
              <div className="text-center animate-fade-in">
                <div className="w-16 h-16 mx-auto bg-gradient-to-br from-blue-100 to-blue-200 rounded-full flex items-center justify-center mb-4 shadow-md">
                  <FiMessageSquare size={32} className="text-blue-600" />
                </div>
                <p className="text-slate-600 text-lg font-semibold">{searchQuery ? 'No conversations found' : 'No conversations yet'}</p>
                <p className="text-slate-500 text-sm mt-2">{searchQuery ? 'Try a different search' : 'Start a new chat to begin'}</p>
              </div>
            </div>
          ) : (
            <div className="space-y-3">
              {filteredConversations.map((conv, index) => (
                <div
                  key={conv.id}
                  onClick={() => handleSelectConversation(conv.id)}
                  className="bg-white rounded-xl p-4 sm:p-5 border border-slate-200 hover:border-blue-500 hover:shadow-xl hover:shadow-blue-500/15 transition-all duration-200 cursor-pointer group animate-fade-in hover:-translate-y-1 focus-visible-ring"
                  style={{ animationDelay: `${index * 50}ms` }}
                >
                  <div className="flex items-start justify-between gap-4">
                    <div className="flex-1 min-w-0">
                      <h3 className="font-bold text-slate-900 truncate group-hover:text-blue-600 transition-colors text-sm sm:text-base flex items-center gap-2">
                        <div className="w-2 h-2 bg-blue-600 rounded-full flex-shrink-0" aria-hidden="true" />
                        <span className="truncate">{conv.title}</span>
                      </h3>
                      <div className="flex items-center gap-3 mt-2 text-xs sm:text-sm text-slate-500 group-hover:text-slate-700 transition-colors">
                        <div className="flex items-center gap-1">
                          <FiClock size={14} className="flex-shrink-0" aria-hidden="true" />
                          <span>{formatDate(conv.createdAt)}</span>
                        </div>
                        <div className="w-1 h-1 bg-slate-300 rounded-full" aria-hidden="true" />
                        <div className="flex items-center gap-1">
                          <FiMessageSquare size={14} className="flex-shrink-0" aria-hidden="true" />
                          <span>{conv.messageCount} message{conv.messageCount !== 1 ? 's' : ''}</span>
                        </div>
                      </div>
                    </div>
                    <button
                      onClick={(e) => handleDeleteConversation(conv.id, e)}
                      className="p-1.5 hover:bg-red-50 rounded transition-all duration-200 opacity-0 group-hover:opacity-100 hover:scale-110 active:scale-95 flex-shrink-0 focus-visible-ring"
                      aria-label="Delete conversation"
                      type="button"
                    >
                      <FiTrash2 size={16} className="text-red-500 transition-transform" />
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

export { ChatHistoryPage }



================================================================================
FILE: src/pages/LandingPage.tsx
================================================================================
import React, { memo } from 'react'
import { useNavigate } from 'react-router-dom'
import { LandingHero } from '../components/landing/LandingHero'
import { LandingFeatures } from '../components/landing/LandingFeatures'
import { LandingHowItWorks } from '../components/landing/LandingHowItWorks'
import { LandingInsightPreview } from '../components/landing/LandingInsightPreview'
import { LandingBenefits } from '../components/landing/LandingBenefits'

const LandingPageComponent: React.FC = () => {
  const navigate = useNavigate()

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 flex flex-col overflow-hidden">
      {/* Animated background elements - Dark theme with vibrant accents */}
      <div className="fixed inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-cyan-500/20 rounded-full mix-blend-screen filter blur-3xl opacity-30 animate-blob" />
        <div className="absolute bottom-0 left-1/4 w-96 h-96 bg-purple-500/20 rounded-full mix-blend-screen filter blur-3xl opacity-30 animate-blob animation-delay-2000" />
        <div className="absolute top-1/2 right-0 w-80 h-80 bg-blue-500/15 rounded-full mix-blend-screen filter blur-3xl opacity-20 animate-blob" style={{ animationDelay: '4s' }} />
        <div className="absolute -bottom-1/2 left-0 w-full h-full bg-gradient-to-t from-slate-950/50 to-transparent pointer-events-none" />
      </div>

      {/* Header with improved navigation */}
      <header className="px-4 sm:px-8 py-5 sm:py-6 bg-slate-950/40 backdrop-blur-xl border-b border-slate-800/50 relative z-10 shadow-lg shadow-slate-950/50">
        <div className="max-w-7xl mx-auto flex items-center justify-between gap-4">
          <button
            onClick={() => navigate('/')}
            className="flex items-center gap-3 group cursor-pointer hover:scale-105 transition-transform duration-300 min-w-0 focus-visible-ring rounded-lg p-1"
            aria-label="Marlamade home"
          >
            <div className="w-11 h-11 bg-gradient-to-br from-cyan-400 to-blue-500 rounded-xl flex items-center justify-center text-slate-950 font-bold shadow-lg shadow-cyan-500/50 group-hover:shadow-xl group-hover:shadow-cyan-400/70 group-hover:scale-110 transition-all duration-300 flex-shrink-0 text-sm">
              CNA
            </div>
            <div className="min-w-0">
              <h1 className="text-xl sm:text-2xl font-bold text-white group-hover:text-cyan-400 transition-colors truncate">
                Marlamade
              </h1>
            </div>
          </button>
          <button
            onClick={() => navigate('/chat')}
            className="px-6 py-2.5 bg-gradient-to-r from-cyan-400 to-blue-500 text-slate-950 rounded-lg font-semibold text-sm shadow-lg shadow-cyan-500/40 hover:shadow-xl hover:shadow-cyan-400/60 hover:scale-105 active:scale-95 transition-all duration-200 focus-visible-ring"
            aria-label="Enter the application"
          >
            Enter App
          </button>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-1 flex flex-col relative z-10">
        <LandingHero />
        <LandingFeatures />
        <LandingHowItWorks />
        <LandingInsightPreview />
        <LandingBenefits />
      </main>
    </div>
  )
}

export const LandingPage = memo(LandingPageComponent)


================================================================================
FILE: src/pages/MainChatPage.tsx
================================================================================
import React, { useEffect, useCallback } from 'react'
import { useLocation, useNavigate } from 'react-router-dom'
import { chatService } from '../services/chatService'
import { voiceNoteService } from '../services/voiceNoteService'
import { titleGenerationService } from '../services/titleGenerationService'
import { logger } from '../services/logger'
import { getApiKeyErrorMessage } from '../services/config'
import { generateTitleFromMessage } from '../utils/titleGenerator'
import { useChatState } from '../hooks/useChatState'
import { useChatOperations } from '../hooks/useChatOperations'
import { useUnderwritingFilters } from '../hooks/useUnderwritingFilters'
import { ChatSidebar } from '../components/ChatSidebar'
import { ChatHeader } from '../components/ChatHeader'
import { ChatMessages } from '../components/ChatMessages'
import { ChatInput } from '../components/ChatInput'
import { UnderwritingFilters } from '../components/UnderwritingFilters'
import { MetadataInputModal } from '../components/MetadataInputModal'
import { ApiErrorBanner } from '../components/ApiErrorBanner'
import { API } from '../constants'
import type { ChatMessage, ConversationMetadata } from '../types'

const MainChatPage: React.FC = () => {
  const location = useLocation()
  const navigate = useNavigate()
  const [linkedVoiceNoteName, setLinkedVoiceNoteName] = React.useState<string | undefined>()
  const [filtersOpen, setFiltersOpen] = React.useState(false)
  const [metadataModalOpen, setMetadataModalOpen] = React.useState(false)

  const {
    conversations,
    currentConversationId,
    messages,
    inputValue,
    isLoading,
    sidebarOpen,
    apiError,
    isApiKeyMissing,
    setConversations,
    setCurrentConversationId,
    setMessages,
    setInputValue,
    setIsLoading,
    setApiError,
    setIsApiKeyMissing,
    resetInput,
    clearError,
    toggleSidebar,
  } = useChatState()

  const {
    filters,
    updateFilters,
    applyFilters,
  } = useUnderwritingFilters()

  const {
    loadConversations,
    loadMessages,
    handleSelectConversation,
    initializeChat,
  } = useChatOperations({
    setConversations,
    setCurrentConversationId,
    setMessages,
    setIsApiKeyMissing,
    setApiError,
  })

  // Handle voice note navigation: create conversation and link voice note
  const handleVoiceNoteNavigation = useCallback(async (voiceNoteId: string) => {
    try {
      logger.info('Processing voice note navigation', { voiceNoteId })

      // Fetch voice note details
      const voiceNote = await voiceNoteService.getVoiceNoteById(voiceNoteId)
      if (!voiceNote) {
        logger.error('Voice note not found', { voiceNoteId })
        setApiError('Voice note not found. Please try uploading again.')
        return
      }

      // Create a new conversation for this voice note
      const title = `Voice Note â€“ ${voiceNote.fileName.split('.')[0]}`
      logger.info('Creating conversation for voice note', { title, voiceNoteId })
      const conversationId = await chatService.createConversation(title, {
        tags: ['voice_note'],
      })

      // Link voice note to conversation
      await voiceNoteService.linkVoiceNoteToConversation(voiceNoteId, conversationId)
      logger.info('Voice note linked to conversation', { voiceNoteId, conversationId })

      // Set as current conversation and display voice note name
      setCurrentConversationId(conversationId)
      setLinkedVoiceNoteName(voiceNote.fileName)
      await loadConversations()

      // Clear navigation state to prevent reprocessing on refresh
      navigate('/chat', { replace: true })

      logger.info('Voice note navigation completed successfully', { conversationId })
    } catch (error) {
      logger.error('Error processing voice note navigation', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to process voice note'
      setApiError(`Error: ${errorMsg}`)
    }
  }, [setCurrentConversationId, loadConversations, navigate, setApiError, setLinkedVoiceNoteName])

  // Load conversations on mount and handle navigation state
  useEffect(() => {
    initializeChat()

    // Handle navigation state: conversationId or voiceNoteId
    const navigationState = location.state as { conversationId?: string; voiceNoteId?: string } | null

    if (navigationState?.conversationId) {
      setCurrentConversationId(navigationState.conversationId)
      logger.debug('Loaded conversation from navigation state', { conversationId: navigationState.conversationId })
    } else if (navigationState?.voiceNoteId) {
      // Handle voice note upload: create new conversation and link voice note
      handleVoiceNoteNavigation(navigationState.voiceNoteId)
    }
  }, [initializeChat, location.state, setCurrentConversationId, handleVoiceNoteNavigation])

  // Load messages when conversation changes
  useEffect(() => {
    if (currentConversationId) {
      loadMessages(currentConversationId)
    }
  }, [currentConversationId, loadMessages])

  const handleSendMessage = useCallback(async () => {
    const trimmedMessage = inputValue.trim()

    // Validate input
    if (!trimmedMessage) {
      return
    }

    if (trimmedMessage.length > 4000) {
      setApiError('Message is too long. Maximum 4000 characters allowed.')
      return
    }

    // Check if API key is configured
    if (isApiKeyMissing) {
      setApiError(getApiKeyErrorMessage())
      return
    }

    const userMessage = trimmedMessage
    logger.info('Sending message', { length: userMessage.length })
    resetInput()

    // Create conversation if it doesn't exist
    let convId = currentConversationId
    if (!convId) {
      try {
        // Use better title generation from first message
        const title = generateTitleFromMessage(userMessage)
        logger.info('Creating new conversation', { title })
        convId = await chatService.createConversation(title)
        logger.info('Conversation created', { id: convId })
        setCurrentConversationId(convId)
        await loadConversations()
      } catch (error) {
        logger.error('Failed to create conversation', error)
        const errorMsg = error instanceof Error ? error.message : 'Failed to create conversation'
        setApiError(`Failed to create conversation: ${errorMsg}`)
        return
      }
    }

    setIsLoading(true)
    clearError()

    // Optimistically add user message to UI
    const optimisticUserMessage: ChatMessage = {
      id: `temp-${Date.now()}`,
      conversationId: convId,
      role: 'user',
      content: userMessage,
      createdAt: new Date(),
    }
    setMessages(prev => [...prev, optimisticUserMessage])

    // Set a timeout to prevent infinite loading
    const timeoutId = setTimeout(() => {
      setIsLoading(false)
      logger.warn('Request timed out', { timeoutMs: API.REQUEST_TIMEOUT_MS })
      setApiError('Request timed out. Please check your connection and try again.')
    }, API.REQUEST_TIMEOUT_MS)

    try {
      logger.info('Sending message to API')
      const assistantResponse = await chatService.sendMessage(convId, userMessage)
      clearTimeout(timeoutId)

      if (!assistantResponse || assistantResponse.trim().length === 0) {
        throw new Error('Received empty response from AI')
      }

      logger.info('API response received', { length: assistantResponse.length })
      clearError()

      // Generate AI-powered 3-word title from the exchange
      try {
        const aiTitle = await titleGenerationService.generateTitle(userMessage, assistantResponse)
        logger.info('Generated AI title', { title: aiTitle })
        await chatService.updateConversationTitle(convId, aiTitle)
        logger.info('Conversation title updated', { id: convId, title: aiTitle })
      } catch (titleError) {
        logger.warn('Failed to generate AI title', titleError)
        // Continue without title update - not critical
      }

      // Reload messages from Firestore to get the persisted versions with real IDs
      logger.debug('Reloading messages from Firestore')
      await loadMessages(convId)
      logger.info('Messages reloaded successfully')
    } catch (error) {
      clearTimeout(timeoutId)
      logger.error('Failed to send message', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to send message'
      setApiError(`Error: ${errorMsg}`)
      // Remove optimistic message on error
      setMessages(prev => prev.filter(msg => msg.id !== optimisticUserMessage.id))
    } finally {
      setIsLoading(false)
    }
  }, [inputValue, currentConversationId, loadConversations, loadMessages, isApiKeyMissing, resetInput, clearError, setCurrentConversationId, setIsLoading, setApiError, setMessages])

  const handleKeyPress = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSendMessage()
    }
  }, [handleSendMessage])

  // Wrapper for new conversation that shows metadata modal
  const handleNewConversationWithMetadata = useCallback(() => {
    setMetadataModalOpen(true)
  }, [])

  // Handle metadata submission
  const handleMetadataSubmit = useCallback(async (metadata: Partial<ConversationMetadata>) => {
    try {
      const title = `Chat ${new Date().toLocaleDateString()}`
      logger.info('Creating new conversation with metadata', { title, hasMetadata: Object.keys(metadata).length > 0 })
      const conversationId = await chatService.createConversation(title, metadata)
      setCurrentConversationId(conversationId)
      setMessages([])
      await loadConversations()
      logger.info('New conversation created successfully', { conversationId })
    } catch (error) {
      logger.error('Failed to create conversation', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to create conversation'
      setApiError(`Error creating conversation: ${errorMsg}`)
    }
  }, [setCurrentConversationId, setMessages, loadConversations, setApiError])

  const handleDeleteConversation = useCallback(async (conversationId: string) => {
    try {
      logger.info('Deleting conversation', { conversationId })
      await chatService.deleteConversation(conversationId)

      // If the deleted conversation was active, clear it
      if (currentConversationId === conversationId) {
        setCurrentConversationId(null)
        setMessages([])
      }

      // Reload conversations
      await loadConversations()
      logger.info('Conversation deleted successfully')
    } catch (error) {
      logger.error('Failed to delete conversation', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to delete conversation'
      setApiError(`Failed to delete conversation: ${errorMsg}`)
    }
  }, [currentConversationId, setCurrentConversationId, setMessages, loadConversations, setApiError])

  const handleRenameConversation = useCallback(async (conversationId: string, newTitle: string) => {
    const trimmedTitle = newTitle.trim()

    if (!trimmedTitle || trimmedTitle.length === 0) {
      setApiError('Conversation title cannot be empty')
      return
    }

    if (trimmedTitle.length > 100) {
      setApiError('Conversation title must be 100 characters or less')
      return
    }

    try {
      logger.info('Renaming conversation', { conversationId, newTitle: trimmedTitle })
      await chatService.updateConversationTitle(conversationId, trimmedTitle)

      // Reload conversations to reflect the change
      await loadConversations()
      logger.info('Conversation renamed successfully')
      clearError()
    } catch (error) {
      logger.error('Failed to rename conversation', error)
      const errorMsg = error instanceof Error ? error.message : 'Failed to rename conversation'
      setApiError(`Failed to rename conversation: ${errorMsg}`)
    }
  }, [loadConversations, setApiError, clearError])

  // Apply filters to conversations
  const filteredConversations = React.useMemo(() => {
    return applyFilters(conversations)
  }, [conversations, applyFilters])

  return (
    <div className="flex h-screen bg-white">
      <ChatSidebar
        isOpen={sidebarOpen}
        conversations={filteredConversations}
        currentConversationId={currentConversationId}
        onNewConversation={handleNewConversationWithMetadata}
        onSelectConversation={handleSelectConversation}
        onDeleteConversation={handleDeleteConversation}
        onRenameConversation={handleRenameConversation}
      />

      {/* Underwriting Filters Panel */}
      <UnderwritingFilters
        onFilterChange={updateFilters}
        activeFilters={filters}
        isOpen={filtersOpen}
        onClose={() => setFiltersOpen(false)}
      />

      <div id="main-content" className="flex-1 flex flex-col" tabIndex={-1}>
        <ChatHeader
          sidebarOpen={sidebarOpen}
          onToggleSidebar={toggleSidebar}
          currentConversationTitle={conversations.find(c => c.id === currentConversationId)?.title}
          linkedVoiceNoteName={linkedVoiceNoteName}
          onOpenFilters={() => setFiltersOpen(true)}
        />
        <ApiErrorBanner error={apiError} onDismiss={clearError} />

        {/* Chat container - clean, focused layout */}
        <div className="flex-1 flex flex-col overflow-hidden">
          <ChatMessages messages={messages} isLoading={isLoading} />
          <ChatInput
            value={inputValue}
            onChange={setInputValue}
            onKeyPress={handleKeyPress}
            onSend={handleSendMessage}
            isLoading={isLoading}
          />
        </div>
      </div>

      {/* Metadata Input Modal */}
      <MetadataInputModal
        isOpen={metadataModalOpen}
        onClose={() => setMetadataModalOpen(false)}
        onSubmit={handleMetadataSubmit}
      />
    </div>
  )
}

export { MainChatPage }



================================================================================
FILE: src/services/chatService.ts
================================================================================
import OpenAI from 'openai'
import { db } from '../firebase'
import { collection, addDoc, query, where, orderBy, getDocs, Timestamp, limit, deleteDoc, doc, updateDoc, increment } from 'firebase/firestore'
import { logger } from './logger'
import { retryWithBackoff } from '../utils/retry'
import { getAPIConfig, getApiKeyErrorMessage, getChatProviderConfig } from './config'
import { toDate } from '../utils/timestampConverter'
import {
  formatChatResponse,
  validateResponse,
  createMetadata,
  parseError,
  handleNullOrUndefinedResponse,
  isHtmlResponse,
  extractErrorFromHtml,
} from '../utils/responseFormatter'
import { createApiCircuitBreaker } from '../utils/circuitBreaker'
import type { ChatMessage, Conversation, ChatMessageInput, IChatProvider, ChatProviderMetadata, ConversationMetadata } from '../types'

/**
 * OpenAI chat provider implementation
 * Handles communication with OpenAI API with retry logic and error handling
 *
 * Note: Currently uses dangerouslyAllowBrowser for frontend-only deployment.
 * In production, this should be replaced with a secure backend proxy that:
 * - Keeps the API key server-side only
 * - Validates requests before forwarding to OpenAI
 * - Implements rate limiting and authentication
 *
 * SECURITY: This provider is development-only. Production deployments MUST use ProxiedChatProvider.
 */
class OpenAIChatProvider implements IChatProvider {
  private client: OpenAI
  private apiConfig = getAPIConfig()
  private circuitBreaker = createApiCircuitBreaker()

  constructor(apiKey: string) {
    // Production-mode guard: prevent dangerouslyAllowBrowser in production
    if (import.meta.env.MODE === 'production') {
      logger.error('OpenAI direct provider with dangerouslyAllowBrowser is not allowed in production', {
        mode: import.meta.env.MODE,
      })
      throw new Error(
        'OpenAI direct provider is not supported in production. ' +
        'Please configure VITE_CHAT_PROVIDER=proxied and VITE_CHAT_PROXY_URL to use a secure backend proxy.'
      )
    }

    logger.warn('Using OpenAI direct provider with dangerouslyAllowBrowser. This is development-only.', {
      mode: import.meta.env.MODE,
    })

    this.client = new OpenAI({
      apiKey,
      dangerouslyAllowBrowser: true, // Development-only: requires production-mode guard above
    })
  }

  async sendMessage(messages: ChatMessageInput[], providerMetadata?: ChatProviderMetadata): Promise<string> {
    const startTime = Date.now()

    try {
      if (!this.client.apiKey) {
        throw new Error(getApiKeyErrorMessage())
      }

      // Cap the number of messages sent to the provider to manage token usage
      // Keep recent N messages to maintain context while controlling costs
      const maxMessagesToSend = 20
      const messagesToSend = messages.slice(-maxMessagesToSend)

      if (messagesToSend.length < messages.length) {
        logger.debug('Truncating message history for API call', {
          total: messages.length,
          sent: messagesToSend.length,
        })
      }

      // If voice notes are provided, prepend a system message with context
      let finalMessages = messagesToSend
      if (providerMetadata?.voiceNoteIds && providerMetadata.voiceNoteIds.length > 0) {
        const systemMessage: ChatMessageInput = {
          role: 'user',
          content: `[Context: This conversation is linked to ${providerMetadata.voiceNoteIds.length} voice note(s). Please consider this context when responding.]`,
        }
        finalMessages = [systemMessage, ...messagesToSend]
      }

      // Execute with circuit breaker protection
      const response = await this.circuitBreaker.execute(() =>
        retryWithBackoff(
          () =>
            this.client.chat.completions.create({
              model: 'gpt-4o-mini',
              messages: finalMessages as OpenAI.Chat.ChatCompletionMessageParam[],
              temperature: 0.7,
              max_tokens: 1000,
            }),
          {
            maxAttempts: this.apiConfig.maxRetries,
            delayMs: this.apiConfig.retryDelay,
            backoffMultiplier: this.apiConfig.backoffMultiplier,
          }
        )
      )

      // Extract and validate response content
      let rawContent = response.choices[0]?.message?.content
      rawContent = handleNullOrUndefinedResponse(rawContent)

      if (!rawContent || rawContent.trim().length === 0) {
        throw new Error('No response content from OpenAI API')
      }

      // Check for HTML error responses
      if (isHtmlResponse(rawContent)) {
        const errorMessage = extractErrorFromHtml(rawContent)
        throw new Error(`Server returned error: ${errorMessage}`)
      }

      // Validate response
      const validation = validateResponse(rawContent)
      if (!validation.isValid) {
        logger.error('Response validation failed', { errors: validation.errors })
        throw new Error(`Invalid response: ${validation.errors.join(', ')}`)
      }

      // Format and sanitize response
      const duration = Date.now() - startTime
      const responseMetadata = createMetadata('openai', duration, 0, 'gpt-4o-mini', {
        prompt: response.usage?.prompt_tokens || 0,
        completion: response.usage?.completion_tokens || 0,
        total: response.usage?.total_tokens || 0,
      })

      const formattedResponse = formatChatResponse(rawContent, responseMetadata, {
        sanitize: true,
        validateSchema: true,
        includeMetadata: true,
      })

      // Log successful response
      logger.logResponseSuccess(
        'openai',
        duration,
        0,
        formattedResponse.length,
        formattedResponse.contentType,
        responseMetadata.tokensUsed
      )
      logger.logResponseTiming('openai', duration, 'OpenAI API call')

      return formattedResponse.content
    } catch (error) {
      logger.error('Error in OpenAIChatProvider.sendMessage', error)
      return this.handleError(error)
    }
  }

  private handleError(error: unknown): never {
    const errorDetails = parseError(error)
    const duration = Date.now() - ((this as unknown as { startTime: number }).startTime || 0)

    // Map error categories to user-friendly messages
    const errorMessages: Record<string, string> = {
      client: 'Invalid request. Please check your input and try again.',
      server: 'OpenAI service is temporarily unavailable. Please try again later.',
      network: 'Network connection error. Please check your internet connection.',
      timeout: 'Request timed out. Please try again.',
      validation: 'Invalid response format received. Please try again.',
      unknown: 'An unexpected error occurred. Please try again.',
    }

    const userMessage = errorMessages[errorDetails.category] || errorMessages.unknown

    // Log error with structured logging
    logger.logResponseError(
      'openai',
      duration,
      0,
      errorDetails.code,
      errorDetails.category,
      'OpenAI API error'
    )

    // Throw user-friendly error
    throw new Error(userMessage)
  }
}

/**
 * Proxied chat provider implementation
 * Sends requests to a backend proxy endpoint (e.g., Cloud Run, Cloud Functions)
 * This keeps the API key server-side only and provides better security
 */
class ProxiedChatProvider implements IChatProvider {
  private proxyUrl: string
  private apiConfig = getAPIConfig()
  private circuitBreaker = createApiCircuitBreaker()

  constructor(proxyUrl: string) {
    if (!proxyUrl) {
      throw new Error('Proxy URL is required for ProxiedChatProvider')
    }
    this.proxyUrl = proxyUrl
    logger.info('ProxiedChatProvider initialized', { proxyUrl: this.proxyUrl })
  }

  async sendMessage(messages: ChatMessageInput[], providerMetadata?: ChatProviderMetadata): Promise<string> {
    const startTime = Date.now()

    try {
      const requestBody = {
        messages,
        metadata: providerMetadata || {},
      }

      logger.debug('Sending request to proxy', { url: this.proxyUrl, messageCount: messages.length })

      // Execute with circuit breaker protection
      const response = await this.circuitBreaker.execute(() =>
        retryWithBackoff(
          () =>
            fetch(this.proxyUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(requestBody),
            }),
          {
            maxAttempts: this.apiConfig.maxRetries,
            delayMs: this.apiConfig.retryDelay,
            backoffMultiplier: this.apiConfig.backoffMultiplier,
          }
        )
      )

      if (!response.ok) {
        const errorText = await response.text()
        // Check if error response is HTML (common for 5xx errors)
        if (isHtmlResponse(errorText)) {
          const errorMessage = extractErrorFromHtml(errorText)
          logger.error('Proxy returned HTML error response', { status: response.status, errorMessage })
          throw new Error(`Proxy error (${response.status}): ${errorMessage}`)
        }

        // Try to parse as JSON error response
        try {
          const errorJson = JSON.parse(errorText)
          const errorMsg = errorJson.error?.message || errorJson.message || errorText
          logger.error('Proxy returned error response', { status: response.status, error: errorMsg })
          throw new Error(`Proxy error (${response.status}): ${errorMsg}`)
        } catch {
          // If JSON parsing fails, use raw text
          logger.error('Proxy returned error response', { status: response.status, errorText: errorText.substring(0, 200) })
          throw new Error(`Proxy returned ${response.status}: ${errorText.substring(0, 200)}`)
        }
      }

      // Parse response JSON with error handling
      let data
      try {
        data = await response.json()
      } catch (parseError) {
        logger.error('Failed to parse proxy response as JSON', { error: parseError })
        throw new Error('Proxy returned invalid JSON response')
      }

      // Validate response structure
      if (!data || typeof data !== 'object') {
        logger.error('Proxy response is not an object', { dataType: typeof data })
        throw new Error('Invalid response format from proxy: response must be an object')
      }

      if (!data.content || typeof data.content !== 'string') {
        logger.error('Proxy response missing content field', { hasContent: !!data.content, contentType: typeof data.content })
        throw new Error('Invalid response format from proxy: missing or invalid content field')
      }

      // Handle null/undefined content
      const content = handleNullOrUndefinedResponse(data.content)
      if (!content || content.trim().length === 0) {
        logger.error('Proxy returned empty content', { contentLength: content?.length || 0 })
        throw new Error('Proxy returned empty content')
      }

      // Validate response
      const validation = validateResponse(content)
      if (!validation.isValid) {
        logger.error('Response validation failed', { errors: validation.errors })
        throw new Error(`Invalid response: ${validation.errors.join(', ')}`)
      }

      // Format and sanitize response
      const duration = Date.now() - startTime
      const responseMetadata = createMetadata('proxied', duration, 0, data.model || 'unknown', {
        prompt: data.tokensUsed?.prompt || 0,
        completion: data.tokensUsed?.completion || 0,
        total: data.tokensUsed?.total || 0,
      })

      const formattedResponse = formatChatResponse(content, responseMetadata, {
        sanitize: true,
        validateSchema: true,
        includeMetadata: true,
      })

      // Log successful response
      logger.logResponseSuccess(
        'proxied',
        duration,
        0,
        formattedResponse.length,
        formattedResponse.contentType,
        responseMetadata.tokensUsed
      )
      logger.logResponseTiming('proxied', duration, 'Proxy API call')

      return formattedResponse.content
    } catch (error) {
      logger.error('Error in ProxiedChatProvider.sendMessage', error)
      return this.handleError(error)
    }
  }

  private handleError(error: unknown): never {
    const errorDetails = parseError(error)
    const duration = Date.now() - ((this as unknown as { startTime: number }).startTime || 0)

    // Map error categories to user-friendly messages
    const errorMessages: Record<string, string> = {
      client: 'Invalid request. Please check your input and try again.',
      server: 'Chat service is temporarily unavailable. Please try again later.',
      network: 'Network connection error. Please check your internet connection.',
      timeout: 'Request timed out. Please try again.',
      validation: 'Invalid response format received. Please try again.',
      unknown: 'An unexpected error occurred. Please try again.',
    }

    const userMessage = errorMessages[errorDetails.category] || errorMessages.unknown

    // Log error with structured logging
    logger.logResponseError(
      'proxied',
      duration,
      0,
      errorDetails.code,
      errorDetails.category,
      'Proxy API error'
    )

    // Throw user-friendly error
    throw new Error(userMessage)
  }
}

// Firestore conversation manager
class FirestoreChatManager {
  private conversationsCollection = 'conversations'
  private messagesCollection = 'messages'

  async createConversation(title: string, metadata?: ConversationMetadata): Promise<string> {
    try {
      logger.info('Creating conversation', { title, hasMetadata: !!metadata })

      const docRef = await addDoc(collection(db, this.conversationsCollection), {
        title,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
        messageCount: 0,
        ...(metadata && { metadata }),
      })

      logger.info('Conversation created', { id: docRef.id })
      return docRef.id
    } catch (error) {
      logger.error('Error creating conversation', error)
      throw error
    }
  }

  async saveMessage(conversationId: string, role: string, content: string): Promise<string> {
    try {
      logger.debug('Saving message', { conversationId, role, contentLength: content.length })

      const docRef = await addDoc(collection(db, this.messagesCollection), {
        conversationId,
        role,
        content,
        createdAt: Timestamp.now(),
      })

      logger.debug('Message saved', { id: docRef.id })

      // Update conversation metadata: increment messageCount and update updatedAt
      // Use atomic increment to avoid race conditions
      try {
        await updateDoc(doc(db, this.conversationsCollection, conversationId), {
          messageCount: increment(1),
          updatedAt: Timestamp.now(),
        })
        logger.debug('Conversation metadata updated', { conversationId })
      } catch (updateError) {
        // Log but don't break chat flow if metadata update fails
        logger.warn('Failed to update conversation metadata', { conversationId, error: updateError })
      }

      return docRef.id
    } catch (error) {
      logger.error('Error saving message', error)
      throw error
    }
  }

  async getConversationMessages(conversationId: string): Promise<ChatMessage[]> {
    try {
      logger.debug('Loading messages for conversation', { conversationId })
      const q = query(
        collection(db, this.messagesCollection),
        where('conversationId', '==', conversationId),
        orderBy('createdAt', 'asc')
      )
      const snapshot = await getDocs(q)
      logger.debug('Messages loaded', { count: snapshot.docs.length })
      return snapshot.docs.map((doc) => {
        const data = doc.data()
        return {
          id: doc.id,
          conversationId: data.conversationId || conversationId,
          role: data.role || 'user',
          content: data.content || '',
          createdAt: toDate(data.createdAt, 'message.createdAt'),
        }
      })
    } catch (error) {
      logger.error('Error loading messages', error)
      throw error
    }
  }

  async getAllConversations(pageSize: number = 50): Promise<Conversation[]> {
    try {
      logger.debug('Loading conversations', { pageSize })
      // Limit to 50 conversations per page to avoid loading too many documents
      const q = query(
        collection(db, this.conversationsCollection),
        orderBy('updatedAt', 'desc'),
        limit(pageSize)
      )
      const snapshot = await getDocs(q)
      logger.debug('Conversations loaded', { count: snapshot.docs.length })

      return snapshot.docs.map((doc) => {
        const data = doc.data()
        // Safely handle missing or malformed fields with sensible defaults
        const createdAt = toDate(data.createdAt, 'conversation.createdAt')
        const updatedAt = toDate(data.updatedAt, 'conversation.updatedAt')

        return {
          id: doc.id,
          title: data.title || 'Untitled Conversation',
          createdAt,
          updatedAt,
          messageCount: typeof data.messageCount === 'number' ? data.messageCount : 0,
          metadata: data.metadata,
        }
      })
    } catch (error) {
      logger.error('Error loading conversations', error)
      throw error
    }
  }

  async deleteConversation(conversationId: string): Promise<void> {
    try {
      logger.info('Deleting conversation', { conversationId })

      // Delete all messages for this conversation
      const messagesQuery = query(
        collection(db, this.messagesCollection),
        where('conversationId', '==', conversationId)
      )
      const messagesSnapshot = await getDocs(messagesQuery)

      for (const messageDoc of messagesSnapshot.docs) {
        await deleteDoc(messageDoc.ref)
      }

      logger.debug('Messages deleted', { count: messagesSnapshot.docs.length })

      // Delete the conversation document
      await deleteDoc(doc(db, this.conversationsCollection, conversationId))

      logger.info('Conversation deleted successfully', { conversationId })
    } catch (error) {
      logger.error('Error deleting conversation', error)
      throw error
    }
  }

  async deleteEmptyConversations(): Promise<number> {
    try {
      logger.info('Starting cleanup of empty conversations')

      const allConversations = await this.getAllConversations(1000)
      let deletedCount = 0

      for (const conversation of allConversations) {
        if (conversation.messageCount === 0) {
          await this.deleteConversation(conversation.id)
          deletedCount++
        }
      }

      logger.info('Cleanup completed', { deletedCount })
      return deletedCount
    } catch (error) {
      logger.error('Error during cleanup', error)
      throw error
    }
  }

  async updateConversationTitle(conversationId: string, newTitle: string): Promise<void> {
    try {
      logger.info('Updating conversation title', { conversationId, newTitle })

      await updateDoc(doc(db, this.conversationsCollection, conversationId), {
        title: newTitle,
        updatedAt: Timestamp.now(),
      })

      logger.info('Conversation title updated', { conversationId })
    } catch (error) {
      logger.error('Error updating conversation title', error)
      throw error
    }
  }

  async updateConversationMetadata(conversationId: string, metadata: ConversationMetadata): Promise<void> {
    try {
      logger.info('Updating conversation metadata', { conversationId })

      await updateDoc(doc(db, this.conversationsCollection, conversationId), {
        metadata,
        updatedAt: Timestamp.now(),
      })

      logger.info('Conversation metadata updated', { conversationId })
    } catch (error) {
      logger.error('Error updating conversation metadata', error)
      throw error
    }
  }
}

// Main chat service
export class ChatService {
  private provider: IChatProvider
  private firestoreManager: FirestoreChatManager

  constructor(provider: IChatProvider) {
    this.provider = provider
    this.firestoreManager = new FirestoreChatManager()
  }

  async sendMessage(conversationId: string, userMessage: string, metadata?: ChatProviderMetadata): Promise<string> {
    try {
      logger.info('Sending message', { conversationId, messageLength: userMessage.length })

      // Save user message
      await this.firestoreManager.saveMessage(conversationId, 'user', userMessage)

      // Get conversation history
      const messages = await this.firestoreManager.getConversationMessages(conversationId)

      // Prepare messages for API
      const apiMessages: ChatMessageInput[] = messages.map((msg) => ({
        role: msg.role,
        content: msg.content,
      }))

      // Get response from provider with optional metadata
      const assistantResponse = await this.provider.sendMessage(apiMessages, metadata)

      if (!assistantResponse) {
        throw new Error('Empty response from AI provider')
      }

      // Save assistant response
      await this.firestoreManager.saveMessage(conversationId, 'assistant', assistantResponse)

      logger.info('Message processed successfully', { conversationId })
      return assistantResponse
    } catch (error) {
      logger.error('Error in sendMessage', error)
      throw error
    }
  }

  async createConversation(title: string, metadata?: ConversationMetadata): Promise<string> {
    return this.firestoreManager.createConversation(title, metadata)
  }

  async getConversationMessages(conversationId: string): Promise<ChatMessage[]> {
    return this.firestoreManager.getConversationMessages(conversationId)
  }

  async getAllConversations(): Promise<Conversation[]> {
    return this.firestoreManager.getAllConversations()
  }

  async deleteConversation(conversationId: string): Promise<void> {
    return this.firestoreManager.deleteConversation(conversationId)
  }

  async deleteEmptyConversations(): Promise<number> {
    return this.firestoreManager.deleteEmptyConversations()
  }

  async updateConversationTitle(conversationId: string, newTitle: string): Promise<void> {
    return this.firestoreManager.updateConversationTitle(conversationId, newTitle)
  }

  async updateConversationMetadata(conversationId: string, metadata: ConversationMetadata): Promise<void> {
    return this.firestoreManager.updateConversationMetadata(conversationId, metadata)
  }

  setProvider(provider: IChatProvider): void {
    this.provider = provider
  }
}

// Initialize chat provider based on configuration
function initializeChatProvider(): IChatProvider {
  const config = getChatProviderConfig()

  // Production mode: enforce proxied provider
  if (import.meta.env.MODE === 'production' && config.provider === 'openai-direct') {
    logger.error('Production mode detected with openai-direct provider. Enforcing proxied provider.', {
      mode: import.meta.env.MODE,
      provider: config.provider,
    })
    if (!config.proxyUrl) {
      throw new Error(
        'Production mode requires VITE_CHAT_PROVIDER=proxied and VITE_CHAT_PROXY_URL to be configured. ' +
        'Direct OpenAI API key usage is not allowed in production.'
      )
    }
    logger.info('Initializing ProxiedChatProvider (enforced for production)', { proxyUrl: config.proxyUrl })
    return new ProxiedChatProvider(config.proxyUrl)
  }

  if (config.provider === 'proxied') {
    if (!config.proxyUrl) {
      logger.error('Proxied provider selected but VITE_CHAT_PROXY_URL is not configured')
      throw new Error('Proxied chat provider requires VITE_CHAT_PROXY_URL to be configured')
    }
    logger.info('Initializing ProxiedChatProvider', { proxyUrl: config.proxyUrl })
    return new ProxiedChatProvider(config.proxyUrl)
  }

  // Development mode: allow OpenAI direct provider (with guard in constructor)
  if (!config.openaiApiKey) {
    logger.warn('OpenAI direct provider selected but VITE_OPENAI_API_KEY is not configured. Chat functionality will not work until configured.')
  }
  logger.info('Initializing OpenAIChatProvider (development mode)', { configured: !!config.openaiApiKey })
  return new OpenAIChatProvider(config.openaiApiKey || '')
}

const provider = initializeChatProvider()
export const chatService = new ChatService(provider)



================================================================================
FILE: src/services/config.ts
================================================================================
/**
 * Centralized configuration service for API and application settings
 * Ensures consistent configuration across the application and prevents sensitive data leaks
 */

import { logger } from './logger'

export interface APIConfig {
  requestTimeout: number
  maxRetries: number
  retryDelay: number
  backoffMultiplier: number
}

export type ChatProvider = 'openai-direct' | 'proxied'

export interface ChatProviderConfig {
  provider: ChatProvider
  openaiApiKey?: string
  proxyUrl?: string
}

// Default API configuration
const DEFAULT_API_CONFIG: APIConfig = {
  requestTimeout: 30000, // 30 seconds
  maxRetries: 3,
  retryDelay: 1000, // 1 second
  backoffMultiplier: 2,
}

/**
 * Get the OpenAI API key from environment variables
 * @returns The API key or undefined if not configured
 */
export function getOpenAIApiKey(): string | undefined {
  const key = import.meta.env.VITE_OPENAI_API_KEY

  if (!key) {
    logger.warn('OpenAI API key is not configured')
    return undefined
  }

  // Ensure we never log the actual key
  logger.debug('OpenAI API key is configured')
  return key
}

/**
 * Check if OpenAI API key is configured
 * @returns true if key is available, false otherwise
 */
export function isOpenAIConfigured(): boolean {
  return !!import.meta.env.VITE_OPENAI_API_KEY
}

/**
 * Get the chat provider configuration
 * @returns Chat provider configuration based on environment variables
 */
export function getChatProviderConfig(): ChatProviderConfig {
  const provider = (import.meta.env.VITE_CHAT_PROVIDER || 'openai-direct') as ChatProvider
  const proxyUrl = import.meta.env.VITE_CHAT_PROXY_URL
  const openaiApiKey = getOpenAIApiKey()

  // Validate configuration
  if (provider === 'proxied' && !proxyUrl) {
    logger.error('Proxied chat provider selected but VITE_CHAT_PROXY_URL is not configured')
  }

  if (provider === 'openai-direct' && !openaiApiKey) {
    logger.warn('OpenAI direct provider selected but VITE_OPENAI_API_KEY is not configured')
  }

  logger.info('Chat provider configured', { provider, hasProxyUrl: !!proxyUrl, hasApiKey: !!openaiApiKey })

  return {
    provider,
    proxyUrl,
    openaiApiKey,
  }
}

/**
 * Get API configuration with optional overrides
 * @param overrides - Partial configuration to override defaults
 * @returns Complete API configuration
 */
export function getAPIConfig(overrides?: Partial<APIConfig>): APIConfig {
  return {
    ...DEFAULT_API_CONFIG,
    ...overrides,
  }
}

/**
 * Get a user-friendly error message for API key issues
 * @returns Error message to display to user
 */
export function getApiKeyErrorMessage(): string {
  return 'âš ï¸ OpenAI API key not configured. Please set VITE_OPENAI_API_KEY in .env.local and restart.'
}



================================================================================
FILE: src/services/logger.ts
================================================================================
type LogLevel = 'debug' | 'info' | 'warn' | 'error'

interface LogEntry {
  level: LogLevel
  message: string
  timestamp: string
  data?: unknown
}

export interface ResponseLogEntry {
  timestamp: Date
  type: 'success' | 'error' | 'warning'
  provider: string
  duration: number
  contentLength?: number
  contentType?: string
  tokensUsed?: {
    prompt: number
    completion: number
    total: number
  }
  errorCode?: string
  errorCategory?: string
  retryCount: number
  message: string
}

/**
 * Logger service with security-first approach
 * Ensures no sensitive data (API keys, tokens, etc.) is ever logged
 * Also handles structured response logging for API interactions
 */
class Logger {
  private isDevelopment = import.meta.env.DEV
  private logs: LogEntry[] = []
  private responseLogs: ResponseLogEntry[] = []
  private maxLogs = 100
  private maxResponseLogs = 1000

  /**
   * Sanitize data to remove sensitive information
   * @param data - Data to sanitize
   * @returns Sanitized data safe for logging
   */
  private sanitizeData(data: unknown): unknown {
    if (!data) return data

    // Don't log strings that might contain sensitive data
    if (typeof data === 'string') {
      // Check for common sensitive patterns
      if (
        data.includes('apiKey') ||
        data.includes('api_key') ||
        data.includes('token') ||
        data.includes('password') ||
        data.includes('secret') ||
        data.includes('VITE_')
      ) {
        return '[REDACTED]'
      }
      return data
    }

    // For objects, recursively sanitize
    if (typeof data === 'object' && data !== null) {
      if (Array.isArray(data)) {
        return data.map(item => this.sanitizeData(item))
      }

      const sanitized: Record<string, unknown> = {}
      for (const [key, value] of Object.entries(data)) {
        // Skip sensitive keys
        if (
          key.toLowerCase().includes('key') ||
          key.toLowerCase().includes('token') ||
          key.toLowerCase().includes('password') ||
          key.toLowerCase().includes('secret')
        ) {
          sanitized[key] = '[REDACTED]'
        } else {
          sanitized[key] = this.sanitizeData(value)
        }
      }
      return sanitized
    }

    return data
  }

  private log(level: LogLevel, message: string, data?: unknown) {
    const sanitizedData = this.sanitizeData(data)
    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date().toISOString(),
      data: sanitizedData,
    }

    this.logs.push(entry)
    if (this.logs.length > this.maxLogs) {
      this.logs.shift()
    }

    if (this.isDevelopment) {
      const style = this.getConsoleStyle(level)
      console.log(`%c[${level.toUpperCase()}]`, style, message, sanitizedData || '')
    }
  }

  private getConsoleStyle(level: LogLevel): string {
    const styles = {
      debug: 'color: #888; font-weight: normal;',
      info: 'color: #0066cc; font-weight: bold;',
      warn: 'color: #ff9900; font-weight: bold;',
      error: 'color: #cc0000; font-weight: bold;',
    }
    return styles[level]
  }

  debug(message: string, data?: unknown) {
    this.log('debug', message, data)
  }

  info(message: string, data?: unknown) {
    this.log('info', message, data)
  }

  warn(message: string, data?: unknown) {
    this.log('warn', message, data)
  }

  error(message: string, data?: unknown) {
    this.log('error', message, data)
  }

  getLogs(): LogEntry[] {
    return [...this.logs]
  }

  clearLogs() {
    this.logs = []
  }

  /**
   * Log successful API response
   */
  logResponseSuccess(
    provider: string,
    duration: number,
    retryCount: number,
    contentLength: number,
    contentType?: string,
    tokensUsed?: { prompt: number; completion: number; total: number }
  ): void {
    const entry: ResponseLogEntry = {
      timestamp: new Date(),
      type: 'success',
      provider,
      duration,
      contentLength,
      contentType,
      tokensUsed,
      retryCount,
      message: 'Response received successfully',
    }
    this.addResponseLog(entry)
    this.info('API response successful', {
      provider,
      duration: `${duration}ms`,
      contentLength,
      contentType,
      tokensUsed,
      retryCount,
    })
  }

  /**
   * Log API response error
   */
  logResponseError(
    provider: string,
    duration: number,
    retryCount: number,
    errorCode?: string,
    errorCategory?: string,
    message?: string
  ): void {
    const entry: ResponseLogEntry = {
      timestamp: new Date(),
      type: 'error',
      provider,
      duration,
      errorCode,
      errorCategory,
      retryCount,
      message: message || 'API response error',
    }
    this.addResponseLog(entry)
    this.error('API response error', {
      provider,
      errorCode,
      errorCategory,
      duration: `${duration}ms`,
      retryCount,
    })
  }

  /**
   * Log API response timing
   */
  logResponseTiming(provider: string, duration: number, operation: string): void {
    this.debug(`${operation} completed`, {
      provider,
      duration: `${duration}ms`,
      performanceCategory: this.categorizePerformance(duration),
    })
  }

  /**
   * Categorize performance based on duration
   */
  private categorizePerformance(duration: number): string {
    if (duration < 500) return 'excellent'
    if (duration < 1000) return 'good'
    if (duration < 2000) return 'acceptable'
    if (duration < 5000) return 'slow'
    return 'very_slow'
  }

  /**
   * Add response log entry
   */
  private addResponseLog(entry: ResponseLogEntry): void {
    this.responseLogs.push(entry)
    if (this.responseLogs.length > this.maxResponseLogs) {
      this.responseLogs = this.responseLogs.slice(-this.maxResponseLogs)
    }
  }

  /**
   * Get response logs
   */
  getResponseLogs(): ResponseLogEntry[] {
    return [...this.responseLogs]
  }

  /**
   * Get response logs by type
   */
  getResponseLogsByType(type: 'success' | 'error' | 'warning'): ResponseLogEntry[] {
    return this.responseLogs.filter((log) => log.type === type)
  }

  /**
   * Get response logs by provider
   */
  getResponseLogsByProvider(provider: string): ResponseLogEntry[] {
    return this.responseLogs.filter((log) => log.provider === provider)
  }

  /**
   * Get response log statistics
   */
  getResponseStatistics() {
    const stats = {
      totalLogs: this.responseLogs.length,
      successCount: 0,
      errorCount: 0,
      warningCount: 0,
      averageDuration: 0,
      totalDuration: 0,
      providers: new Set<string>(),
    }

    for (const log of this.responseLogs) {
      if (log.type === 'success') stats.successCount++
      if (log.type === 'error') stats.errorCount++
      if (log.type === 'warning') stats.warningCount++
      stats.totalDuration += log.duration
      stats.providers.add(log.provider)
    }

    stats.averageDuration = this.responseLogs.length > 0 ? stats.totalDuration / this.responseLogs.length : 0

    return {
      ...stats,
      providers: Array.from(stats.providers),
    }
  }

  /**
   * Clear response logs
   */
  clearResponseLogs(): void {
    this.responseLogs = []
  }
}

export const logger = new Logger()



================================================================================
FILE: src/services/titleGenerationService.ts
================================================================================
import { logger } from './logger'

/**
 * Service for generating concise 3-word titles from chat responses
 * Uses heuristic-based title generation for fast, reliable, and secure title creation
 * No external API calls or dangerouslyAllowBrowser usage
 *
 * SECURITY: This service no longer uses OpenAI directly. All title generation is client-side heuristic-based.
 */
class TitleGenerationService {
  /**
   * Generate a 3-word title from a user message and AI response
   * Uses heuristic-based extraction for speed and reliability
   * @param userMessage - The user's question/message
   * @param aiResponse - The AI's response
   * @returns A 3-word title or fallback title
   */
  async generateTitle(userMessage: string, aiResponse: string): Promise<string> {
    try {
      logger.debug('Generating title from user message and AI response')

      // Try to extract meaningful title from the exchange
      const title = this.extractTitleFromExchange(userMessage, aiResponse)

      if (title && title.length > 0) {
        logger.info('Title generated successfully', { title })
        return title
      }

      // Fallback to user message-based title
      logger.debug('Using fallback title from user message')
      return this.generateFallbackTitle(userMessage)
    } catch (error) {
      logger.error('Error generating title', error)
      return this.generateFallbackTitle(userMessage)
    }
  }

  /**
   * Extract a meaningful title from the user message and AI response
   * Uses heuristic-based extraction of key phrases
   */
  private extractTitleFromExchange(userMessage: string, aiResponse: string): string {
    // Prefer extracting from user message (more direct intent)
    const userTitle = this.extractKeyPhrasesFromText(userMessage)
    if (userTitle && userTitle.length > 0) {
      return userTitle
    }

    // Fallback to AI response
    const aiTitle = this.extractKeyPhrasesFromText(aiResponse)
    if (aiTitle && aiTitle.length > 0) {
      return aiTitle
    }

    return ''
  }

  /**
   * Extract key phrases from text to form a title
   * Prioritizes first sentence and important keywords
   */
  private extractKeyPhrasesFromText(text: string): string {
    if (!text || text.length === 0) {
      return ''
    }

    // Get first sentence (up to first period, question mark, or exclamation)
    const firstSentenceMatch = text.match(/^[^.!?]*[.!?]?/)
    const firstSentence = firstSentenceMatch ? firstSentenceMatch[0].trim() : text

    // Extract words, filtering out common stop words
    const stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
      'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
      'can', 'could', 'will', 'would', 'should', 'may', 'might', 'must', 'shall', 'this', 'that',
      'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'what', 'which', 'who', 'when',
      'where', 'why', 'how', 'as', 'if', 'from', 'up', 'about', 'out', 'into', 'through', 'during',
    ])

    const words = firstSentence
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '') // Remove punctuation
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.has(word))
      .slice(0, 3) // Take first 3 meaningful words

    if (words.length === 0) {
      return ''
    }

    // Capitalize each word
    const title = words
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ')

    // Ensure we have exactly 3 words
    return this.ensureThreeWords(title)
  }

  /**
   * Ensure title has exactly 3 words
   * Pads with generic words if needed
   */
  private ensureThreeWords(title: string): string {
    const words = title.split(/\s+/).filter(w => w.length > 0)

    if (words.length >= 3) {
      return words.slice(0, 3).join(' ')
    }

    // Pad with generic words if less than 3
    const genericWords = ['Chat', 'Discussion', 'Query']
    while (words.length < 3) {
      words.push(genericWords[words.length % genericWords.length])
    }

    return words.slice(0, 3).join(' ')
  }

  /**
   * Generate a fallback title from the user message
   * Used when extraction fails
   */
  private generateFallbackTitle(userMessage: string): string {
    if (!userMessage || userMessage.length === 0) {
      return 'Chat Discussion Query'
    }

    const cleaned = userMessage.trim()

    // Extract first 3 words, removing punctuation
    const words = cleaned
      .replace(/[^a-z0-9\s]/gi, '')
      .split(/\s+/)
      .filter(w => w.length > 0)
      .slice(0, 3)
      .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())

    if (words.length >= 3) {
      return words.join(' ')
    }

    // Pad with generic words if needed
    const genericWords = ['Chat', 'Discussion', 'Query']
    while (words.length < 3) {
      words.push(genericWords[words.length % genericWords.length])
    }

    return words.slice(0, 3).join(' ')
  }
}

export const titleGenerationService = new TitleGenerationService()



================================================================================
FILE: src/services/voiceNoteService.ts
================================================================================
/**
 * Voice note service for handling audio uploads and Firestore records
 * Manages Firebase Storage uploads and VoiceNote metadata persistence
 */

import { storage, db } from '../firebase'
import { ref, uploadBytesResumable } from 'firebase/storage'
import { collection, addDoc, Timestamp, getDocs, query, doc, getDoc, updateDoc } from 'firebase/firestore'
import { logger } from './logger'
import { toDate } from '../utils/timestampConverter'
import type { VoiceNote, VoiceNoteStatus } from '../types'

export interface UploadProgress {
  bytesTransferred: number
  totalBytes: number
  progress: number
}

export interface UploadResult {
  voiceNote: VoiceNote
  storagePath: string
}

class VoiceNoteService {
  private voiceNotesCollection = 'voiceNotes'

  /**
   * Upload an audio file to Firebase Storage and create a VoiceNote record
   * @param file - The audio file to upload
   * @param onProgress - Callback for upload progress updates
   * @returns Promise with the created VoiceNote and storage path
   */
  async uploadAudioFile(
    file: File,
    onProgress?: (progress: UploadProgress) => void
  ): Promise<UploadResult> {
    try {
      logger.info('Starting audio file upload', { fileName: file.name, fileSize: file.size })

      // Create storage path: voice-notes/{timestamp}_{filename}
      const timestamp = Date.now()
      const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')
      const storagePath = `voice-notes/${timestamp}_${sanitizedFileName}`

      // Create upload task
      const storageRef = ref(storage, storagePath)
      const uploadTask = uploadBytesResumable(storageRef, file)

      // Handle upload progress
      return new Promise((resolve, reject) => {
        uploadTask.on(
          'state_changed',
          (snapshot) => {
            const progress: UploadProgress = {
              bytesTransferred: snapshot.bytesTransferred,
              totalBytes: snapshot.totalBytes,
              progress: (snapshot.bytesTransferred / snapshot.totalBytes) * 100,
            }
            onProgress?.(progress)
            logger.debug('Upload progress', { progress: progress.progress })
          },
          (error) => {
            logger.error('Upload failed', error)
            reject(error)
          },
          async () => {
            try {
              // Upload completed successfully, create Firestore record
              const voiceNote = await this.createVoiceNoteRecord(file.name, storagePath)
              logger.info('Audio file uploaded successfully', { voiceNoteId: voiceNote.id })
              resolve({ voiceNote, storagePath })
            } catch (error) {
              logger.error('Failed to create voice note record', error)
              reject(error)
            }
          }
        )
      })
    } catch (error) {
      logger.error('Error uploading audio file', error)
      throw error
    }
  }

  /**
   * Create a VoiceNote record in Firestore
   * @param fileName - The name of the uploaded file
   * @param storagePath - The path in Firebase Storage
   * @returns The created VoiceNote
   */
  private async createVoiceNoteRecord(fileName: string, storagePath: string): Promise<VoiceNote> {
    try {
      const now = Timestamp.now()
      const docRef = await addDoc(collection(db, this.voiceNotesCollection), {
        fileName,
        storagePath,
        status: 'uploaded',
        createdAt: now,
        updatedAt: now,
      })

      logger.info('Voice note record created', { id: docRef.id })

      return {
        id: docRef.id,
        fileName,
        storagePath,
        status: 'uploaded',
        createdAt: now.toDate(),
        updatedAt: now.toDate(),
      }
    } catch (error) {
      logger.error('Error creating voice note record', error)
      throw error
    }
  }

  /**
   * Get a voice note by ID
   * @param voiceNoteId - The ID of the voice note
   * @returns The VoiceNote or undefined if not found
   */
  async getVoiceNoteById(voiceNoteId: string): Promise<VoiceNote | undefined> {
    try {
      logger.debug('Fetching voice note', { voiceNoteId })
      const docRef = doc(db, this.voiceNotesCollection, voiceNoteId)
      const docSnap = await getDoc(docRef)

      if (!docSnap.exists()) {
        logger.warn('Voice note not found', { voiceNoteId })
        return undefined
      }

      const data = docSnap.data()
      return {
        id: docSnap.id,
        fileName: data.fileName || 'Unknown',
        storagePath: data.storagePath || '',
        status: (data.status || 'uploaded') as VoiceNoteStatus,
        createdAt: toDate(data.createdAt, 'voiceNote.createdAt'),
        updatedAt: toDate(data.updatedAt, 'voiceNote.updatedAt'),
        transcriptId: data.transcriptId,
        transcriptSummary: data.transcriptSummary,
        conversationId: data.conversationId,
      }
    } catch (error) {
      logger.error('Error fetching voice note', error)
      throw error
    }
  }

  /**
   * Get all voice notes for the current user
   * @returns Array of VoiceNote objects
   */
  async getAllVoiceNotes(): Promise<VoiceNote[]> {
    try {
      logger.debug('Fetching all voice notes')
      const q = query(collection(db, this.voiceNotesCollection))
      const snapshot = await getDocs(q)

      return snapshot.docs.map((docSnap) => {
        const data = docSnap.data()
        return {
          id: docSnap.id,
          fileName: data.fileName || 'Unknown',
          storagePath: data.storagePath || '',
          status: (data.status || 'uploaded') as VoiceNoteStatus,
          createdAt: toDate(data.createdAt, 'voiceNote.createdAt'),
          updatedAt: toDate(data.updatedAt, 'voiceNote.updatedAt'),
          transcriptId: data.transcriptId,
          transcriptSummary: data.transcriptSummary,
          conversationId: data.conversationId,
        }
      })
    } catch (error) {
      logger.error('Error fetching voice notes', error)
      throw error
    }
  }

  /**
   * Link a voice note to a conversation
   * @param voiceNoteId - The ID of the voice note
   * @param conversationId - The ID of the conversation
   */
  async linkVoiceNoteToConversation(voiceNoteId: string, conversationId: string): Promise<void> {
    try {
      logger.info('Linking voice note to conversation', { voiceNoteId, conversationId })
      const docRef = doc(db, this.voiceNotesCollection, voiceNoteId)
      await updateDoc(docRef, {
        conversationId,
        updatedAt: Timestamp.now(),
      })
      logger.info('Voice note linked successfully', { voiceNoteId, conversationId })
    } catch (error) {
      logger.error('Error linking voice note to conversation', error)
      throw error
    }
  }
}

export const voiceNoteService = new VoiceNoteService()



================================================================================
FILE: src/types/index.ts
================================================================================
/**
 * Core type definitions for the CNA Voice Notes AI application
 * Centralized type definitions for better maintainability and AI comprehension
 */

/** Message role in a conversation */
export type MessageRole = 'user' | 'assistant'

/** A single message in a conversation */
export interface ChatMessage {
  id: string
  conversationId: string
  role: MessageRole
  content: string
  createdAt: Date
}

/** Metadata for filtering conversations */
export interface ConversationMetadata {
  // Broker Information
  broker?: string
  brokerCode?: string

  // Line of Business (LOB)
  lob?: string // e.g., "commercial_general_liability", "property", "workers_compensation"

  // Business Type
  businessType?: string // e.g., "new_business", "renewal", "modification", "cancellation"

  // Client/Account Information
  client?: string
  accountNumber?: string

  // Risk Categories
  riskCategory?: string // e.g., "manufacturing", "retail", "healthcare", "technology"
  industry?: string

  // Coverage Details
  coverageType?: string
  premium?: number

  // Underwriting Status
  underwritingStatus?: string // e.g., "pending", "approved", "declined", "referred"

  // Additional Tags
  tags?: string[]

  // Generic key-value storage
  [key: string]: string | string[] | number | boolean | undefined
}

/** A conversation/chat session */
export interface Conversation {
  id: string
  title: string
  createdAt: Date
  updatedAt: Date
  messageCount: number
  metadata?: ConversationMetadata
}

/** Input format for sending messages to the API */
export interface ChatMessageInput {
  role: MessageRole
  content: string
}

/** Extended chat provider interface with optional metadata support */
export interface IChatProvider {
  sendMessage(messages: ChatMessageInput[], metadata?: ChatProviderMetadata): Promise<string>
}

/** Optional metadata to send with chat provider requests */
export interface ChatProviderMetadata {
  conversationId?: string
  voiceNoteIds?: string[]
  context?: Record<string, unknown>
}

/** Configuration for API timeouts and retries */
export interface APIConfig {
  requestTimeout: number
  maxRetries: number
  retryDelay: number
}

// ============================================================================
// RESPONSE FORMATTING TYPES
// ============================================================================

/** Response metadata for tracking and debugging */
export interface ResponseMetadata {
  timestamp: Date
  duration: number // milliseconds
  retryCount: number
  provider: string
  model?: string
  tokensUsed?: {
    prompt: number
    completion: number
    total: number
  }
}

/** Error details with categorization */
export interface ErrorDetails {
  code: string
  message: string
  category: 'client' | 'server' | 'network' | 'timeout' | 'validation' | 'unknown'
  statusCode?: number
  retryable: boolean
  originalError?: unknown
}

/** Standard response envelope for all API responses */
export interface ApiResponse<T = unknown> {
  success: boolean
  data?: T
  error?: ErrorDetails
  metadata: ResponseMetadata
}

/** Formatted chat response with content and metadata */
export interface FormattedChatResponse {
  content: string
  contentType: 'text' | 'markdown' | 'json' | 'mixed'
  length: number
  hasFormatting: boolean
  sanitized: boolean
  metadata: {
    model: string
    temperature: number
    maxTokens: number
    finishReason?: string
  }
}

/** Response validation result */
export interface ValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
  sanitized: boolean
}

/** Response formatting options */
export interface ResponseFormattingOptions {
  sanitize: boolean
  validateSchema: boolean
  includeMetadata: boolean
  formatMarkdown: boolean
  maxLength?: number
  timeout?: number
}

/** Streaming response chunk */
export interface StreamingChunk {
  id: string
  timestamp: Date
  content: string
  isComplete: boolean
  error?: ErrorDetails
}

/** Streaming response handler options */
export interface StreamingOptions {
  onChunk?: (chunk: StreamingChunk) => void
  onComplete?: (fullContent: string) => void
  onError?: (error: ErrorDetails) => void
  timeout?: number
  maxChunks?: number
}

/** Response cache entry */
export interface CacheEntry<T> {
  data: T
  timestamp: Date
  ttl: number // milliseconds
  hits: number
}

/** Circuit breaker state */
export type CircuitBreakerState = 'closed' | 'open' | 'half-open'

/** Circuit breaker configuration */
export interface CircuitBreakerConfig {
  failureThreshold: number // number of failures before opening
  successThreshold: number // number of successes to close from half-open
  timeout: number // milliseconds before attempting half-open
  monitoringWindow: number // milliseconds to track failures
}

/** Circuit breaker status */
export interface CircuitBreakerStatus {
  state: CircuitBreakerState
  failureCount: number
  successCount: number
  lastFailureTime?: Date
  nextAttemptTime?: Date
}

/** Comprehensive response envelope with additional metadata */
export interface EnhancedApiResponse<T = unknown> extends ApiResponse<T> {
  cached?: boolean
  streaming?: boolean
  partial?: boolean
  retryInfo?: {
    attempt: number
    maxAttempts: number
    nextRetryTime?: Date
  }
}

/** Voice note status */
export type VoiceNoteStatus = 'uploaded' | 'processing' | 'ready' | 'error'

/** A voice note record */
export interface VoiceNote {
  id: string
  fileName: string
  storagePath: string
  status: VoiceNoteStatus
  createdAt: Date
  updatedAt: Date
  transcriptId?: string
  transcriptSummary?: string
  conversationId?: string
}


================================================================================
FILE: src/utils/circuitBreaker.ts
================================================================================
import { logger } from '../services/logger'
import type { CircuitBreakerConfig, CircuitBreakerState, CircuitBreakerStatus } from '../types'

/**
 * Circuit Breaker Pattern Implementation
 * Prevents cascading failures and manages service degradation
 */

export class CircuitBreaker {
  private state: CircuitBreakerState = 'closed'
  private failureCount = 0
  private successCount = 0
  private lastFailureTime?: Date
  private nextAttemptTime?: Date
  private config: CircuitBreakerConfig

  constructor(config: Partial<CircuitBreakerConfig> = {}) {
    this.config = {
      failureThreshold: config.failureThreshold || 5,
      successThreshold: config.successThreshold || 2,
      timeout: config.timeout || 60000,
      monitoringWindow: config.monitoringWindow || 120000,
    }
  }

  /**
   * Execute function with circuit breaker protection
   */
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (this.shouldAttemptReset()) {
        this.state = 'half-open'
        logger.info('Circuit breaker transitioning to half-open state')
      } else {
        throw new Error('Circuit breaker is open. Service is unavailable.')
      }
    }

    try {
      const result = await fn()
      this.onSuccess()
      return result
    } catch (error) {
      this.onFailure()
      throw error
    }
  }

  /**
   * Handle successful execution
   */
  private onSuccess(): void {
    this.failureCount = 0

    if (this.state === 'half-open') {
      this.successCount++
      if (this.successCount >= this.config.successThreshold) {
        this.state = 'closed'
        this.successCount = 0
        logger.info('Circuit breaker closed - service recovered')
      }
    }
  }

  /**
   * Handle failed execution
   */
  private onFailure(): void {
    this.lastFailureTime = new Date()
    this.failureCount++

    if (this.state === 'half-open') {
      this.state = 'open'
      this.nextAttemptTime = new Date(Date.now() + this.config.timeout)
      logger.warn('Circuit breaker opened - service degraded')
    } else if (this.state === 'closed' && this.failureCount >= this.config.failureThreshold) {
      this.state = 'open'
      this.nextAttemptTime = new Date(Date.now() + this.config.timeout)
      logger.error('Circuit breaker opened - threshold exceeded', {
        failureCount: this.failureCount,
        threshold: this.config.failureThreshold,
      })
    }
  }

  /**
   * Check if should attempt reset
   */
  private shouldAttemptReset(): boolean {
    if (!this.nextAttemptTime) return true
    return Date.now() >= this.nextAttemptTime.getTime()
  }

  /**
   * Get current status
   */
  getStatus(): CircuitBreakerStatus {
    return {
      state: this.state,
      failureCount: this.failureCount,
      successCount: this.successCount,
      lastFailureTime: this.lastFailureTime,
      nextAttemptTime: this.nextAttemptTime,
    }
  }

  /**
   * Reset circuit breaker
   */
  reset(): void {
    this.state = 'closed'
    this.failureCount = 0
    this.successCount = 0
    this.lastFailureTime = undefined
    this.nextAttemptTime = undefined
    logger.info('Circuit breaker reset')
  }

  /**
   * Check if circuit is open
   */
  isOpen(): boolean {
    return this.state === 'open'
  }

  /**
   * Check if circuit is closed
   */
  isClosed(): boolean {
    return this.state === 'closed'
  }

  /**
   * Check if circuit is half-open
   */
  isHalfOpen(): boolean {
    return this.state === 'half-open'
  }
}

/**
 * Create a circuit breaker for API calls
 */
export function createApiCircuitBreaker(): CircuitBreaker {
  return new CircuitBreaker({
    failureThreshold: 5,
    successThreshold: 2,
    timeout: 60000,
    monitoringWindow: 120000,
  })
}



================================================================================
FILE: src/utils/conversationGrouper.ts
================================================================================
/**
 * Conversation grouping utilities
 * Provides consistent date-based grouping for conversations across the app
 */

import type { Conversation } from '../types'

export type ConversationGroup = 'Today' | 'Yesterday' | 'This Week' | 'This Month' | 'Older'

export type GroupedConversations = Partial<Record<ConversationGroup, Conversation[]>>

/**
 * Determine which group a conversation belongs to based on its updatedAt date
 * @param date - The date to categorize
 * @returns The group name
 */
export function getConversationGroup(date: Date): ConversationGroup {
  const now = new Date()
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())
  const yesterday = new Date(today)
  yesterday.setDate(yesterday.getDate() - 1)
  const weekAgo = new Date(today)
  weekAgo.setDate(weekAgo.getDate() - 7)
  const monthAgo = new Date(today)
  monthAgo.setMonth(monthAgo.getMonth() - 1)

  const conversationDate = new Date(date.getFullYear(), date.getMonth(), date.getDate())

  if (conversationDate.getTime() === today.getTime()) {
    return 'Today'
  }
  if (conversationDate.getTime() === yesterday.getTime()) {
    return 'Yesterday'
  }
  if (conversationDate.getTime() > weekAgo.getTime()) {
    return 'This Week'
  }
  if (conversationDate.getTime() > monthAgo.getTime()) {
    return 'This Month'
  }
  return 'Older'
}

/**
 * Group conversations by date
 * @param conversations - Array of conversations to group
 * @returns Object with conversations grouped by date
 */
export function groupConversationsByDate(conversations: Conversation[]): GroupedConversations {
  const grouped: GroupedConversations = {}

  for (const conversation of conversations) {
    const group = getConversationGroup(conversation.updatedAt)
    if (!grouped[group]) {
      grouped[group] = []
    }
    grouped[group]!.push(conversation)
  }

  return grouped
}

/**
 * Get the order of groups for consistent display
 * @returns Array of group names in display order
 */
export function getGroupOrder(): ConversationGroup[] {
  return ['Today', 'Yesterday', 'This Week', 'This Month', 'Older']
}

/**
 * Get grouped conversations in display order
 * @param conversations - Array of conversations to group
 * @returns Array of [groupName, conversations] tuples in display order
 */
export function getOrderedGroupedConversations(
  conversations: Conversation[]
): Array<[ConversationGroup, Conversation[]]> {
  const grouped = groupConversationsByDate(conversations)
  const order = getGroupOrder()

  return order
    .filter(group => grouped[group] && grouped[group]!.length > 0)
    .map(group => [group, grouped[group]!])
}



================================================================================
FILE: src/utils/dates.ts
================================================================================
/**
 * Date and time utilities
 * Provides consistent date operations across the application
 */

import { DATE_GROUPS } from '../constants'

/**
 * Get the number of days between two dates
 * @param date1 - First date
 * @param date2 - Second date (defaults to now)
 * @returns Number of days difference
 */
export function getDaysDifference(date1: Date | number, date2: Date | number = new Date()): number {
  const d1 = typeof date1 === 'number' ? new Date(date1) : date1
  const d2 = typeof date2 === 'number' ? new Date(date2) : date2
  const diffTime = Math.abs(d2.getTime() - d1.getTime())
  return Math.floor(diffTime / (1000 * 60 * 60 * 24))
}

/**
 * Check if a date is today
 * @param date - Date to check
 * @returns true if date is today
 */
export function isToday(date: Date | number): boolean {
  return getDaysDifference(date) === 0
}

/**
 * Check if a date is yesterday
 * @param date - Date to check
 * @returns true if date is yesterday
 */
export function isYesterday(date: Date | number): boolean {
  return getDaysDifference(date) === 1
}

/**
 * Check if a date is in the current week
 * @param date - Date to check
 * @returns true if date is in current week
 */
export function isThisWeek(date: Date | number): boolean {
  const daysDiff = getDaysDifference(date)
  return daysDiff >= 0 && daysDiff < 7
}

/**
 * Check if a date is in the current month
 * @param date - Date to check
 * @returns true if date is in current month
 */
export function isThisMonth(date: Date | number): boolean {
  const daysDiff = getDaysDifference(date)
  return daysDiff >= 0 && daysDiff < 30
}

/**
 * Get the date group label for a date
 * @param date - Date to categorize
 * @returns Date group label
 */
export function getDateGroupLabel(date: Date | number): string {
  const daysDiff = getDaysDifference(date)

  if (daysDiff === 0) return DATE_GROUPS.TODAY
  if (daysDiff === 1) return DATE_GROUPS.YESTERDAY
  if (daysDiff < 7) return DATE_GROUPS.THIS_WEEK
  if (daysDiff < 30) return DATE_GROUPS.THIS_MONTH
  return DATE_GROUPS.OLDER
}

/**
 * Group dates by their label
 * @param dates - Array of dates to group
 * @returns Object with date group labels as keys and dates as values
 */
export function groupDatesByLabel(dates: (Date | number)[]): Record<string, (Date | number)[]> {
  const groups: Record<string, (Date | number)[]> = {}

  dates.forEach(date => {
    const label = getDateGroupLabel(date)
    if (!groups[label]) {
      groups[label] = []
    }
    groups[label].push(date)
  })

  return groups
}

/**
 * Get the start of the day for a date
 * @param date - Date to get start of day for
 * @returns Date at start of day (00:00:00)
 */
export function getStartOfDay(date: Date | number): Date {
  const d = typeof date === 'number' ? new Date(date) : new Date(date)
  d.setHours(0, 0, 0, 0)
  return d
}

/**
 * Get the end of the day for a date
 * @param date - Date to get end of day for
 * @returns Date at end of day (23:59:59)
 */
export function getEndOfDay(date: Date | number): Date {
  const d = typeof date === 'number' ? new Date(date) : new Date(date)
  d.setHours(23, 59, 59, 999)
  return d
}

/**
 * Format relative time (e.g., "2 hours ago")
 * @param date - Date to format
 * @returns Relative time string
 */
export function formatRelativeTime(date: Date | number): string {
  const d = typeof date === 'number' ? new Date(date) : date
  const now = new Date()
  const diffMs = now.getTime() - d.getTime()
  const diffSecs = Math.floor(diffMs / 1000)
  const diffMins = Math.floor(diffSecs / 60)
  const diffHours = Math.floor(diffMins / 60)
  const diffDays = Math.floor(diffHours / 24)

  if (diffSecs < 60) return 'just now'
  if (diffMins < 60) return `${diffMins}m ago`
  if (diffHours < 24) return `${diffHours}h ago`
  if (diffDays < 7) return `${diffDays}d ago`
  return d.toLocaleDateString()
}



================================================================================
FILE: src/utils/errorHandler.ts
================================================================================
import { logger } from '../services/logger'
import type { ErrorDetails } from '../types'

/**
 * Comprehensive Error Handler
 * Handles all response failure scenarios with categorization and recovery strategies
 */

export interface ErrorContext {
  operation: string
  provider: string
  duration?: number
  retryCount?: number
  originalError?: unknown
}

export interface ErrorRecoveryStrategy {
  shouldRetry: boolean
  retryDelay: number
  maxRetries: number
  userMessage: string
  logLevel: 'error' | 'warn' | 'info'
}

/**
 * Categorize and handle different error types
 */
export function handleResponseError(
  error: unknown
): { details: ErrorDetails; strategy: ErrorRecoveryStrategy } {
  const message = error instanceof Error ? error.message : String(error)
  const lowerMessage = message.toLowerCase()

  let category: ErrorDetails['category'] = 'unknown'
  let statusCode: number | undefined
  let retryable = true
  let strategy: ErrorRecoveryStrategy

  // Timeout errors
  if (lowerMessage.includes('timeout') || lowerMessage.includes('timed out')) {
    category = 'timeout'
    statusCode = 408
    strategy = {
      shouldRetry: true,
      retryDelay: 2000,
      maxRetries: 3,
      userMessage: 'Request timed out. Please try again.',
      logLevel: 'warn',
    }
  }
  // Network errors
  else if (
    lowerMessage.includes('network') ||
    lowerMessage.includes('fetch') ||
    lowerMessage.includes('econnrefused') ||
    lowerMessage.includes('enotfound')
  ) {
    category = 'network'
    strategy = {
      shouldRetry: true,
      retryDelay: 3000,
      maxRetries: 3,
      userMessage: 'Network connection error. Please check your internet and try again.',
      logLevel: 'warn',
    }
  }
  // Rate limit errors
  else if (lowerMessage.includes('429') || lowerMessage.includes('rate')) {
    category = 'client'
    statusCode = 429
    strategy = {
      shouldRetry: true,
      retryDelay: 5000,
      maxRetries: 5,
      userMessage: 'Too many requests. Please wait a moment and try again.',
      logLevel: 'warn',
    }
  }
  // Authentication errors
  else if (lowerMessage.includes('401') || lowerMessage.includes('unauthorized')) {
    category = 'client'
    statusCode = 401
    retryable = false
    strategy = {
      shouldRetry: false,
      retryDelay: 0,
      maxRetries: 0,
      userMessage: 'Authentication failed. Please check your API key.',
      logLevel: 'error',
    }
  }
  // Authorization errors
  else if (lowerMessage.includes('403') || lowerMessage.includes('forbidden')) {
    category = 'client'
    statusCode = 403
    retryable = false
    strategy = {
      shouldRetry: false,
      retryDelay: 0,
      maxRetries: 0,
      userMessage: 'Access denied. You do not have permission to perform this action.',
      logLevel: 'error',
    }
  }
  // Bad request errors
  else if (lowerMessage.includes('400') || lowerMessage.includes('bad request')) {
    category = 'validation'
    statusCode = 400
    retryable = false
    strategy = {
      shouldRetry: false,
      retryDelay: 0,
      maxRetries: 0,
      userMessage: 'Invalid request. Please check your input and try again.',
      logLevel: 'error',
    }
  }
  // Server errors
  else if (
    lowerMessage.includes('500') ||
    lowerMessage.includes('502') ||
    lowerMessage.includes('503') ||
    lowerMessage.includes('504') ||
    lowerMessage.includes('server')
  ) {
    category = 'server'
    statusCode = 500
    strategy = {
      shouldRetry: true,
      retryDelay: 4000,
      maxRetries: 3,
      userMessage: 'Server error. Please try again later.',
      logLevel: 'error',
    }
  }
  // Malformed response
  else if (lowerMessage.includes('malformed') || lowerMessage.includes('invalid')) {
    category = 'validation'
    strategy = {
      shouldRetry: true,
      retryDelay: 1000,
      maxRetries: 2,
      userMessage: 'Invalid response received. Please try again.',
      logLevel: 'warn',
    }
  }
  // Default unknown error
  else {
    category = 'unknown'
    strategy = {
      shouldRetry: true,
      retryDelay: 2000,
      maxRetries: 2,
      userMessage: 'An unexpected error occurred. Please try again.',
      logLevel: 'error',
    }
  }

  const errorDetails: ErrorDetails = {
    code: `${category.toUpperCase()}_ERROR`,
    message,
    category,
    statusCode,
    retryable,
    originalError: error,
  }

  return { details: errorDetails, strategy }
}

/**
 * Log error with context
 */
export function logErrorWithContext(
  error: ErrorDetails,
  context: ErrorContext,
  strategy: ErrorRecoveryStrategy
): void {
  const logData = {
    operation: context.operation,
    provider: context.provider,
    errorCode: error.code,
    errorCategory: error.category,
    statusCode: error.statusCode,
    message: error.message,
    retryable: error.retryable,
    shouldRetry: strategy.shouldRetry,
    duration: context.duration,
    retryCount: context.retryCount,
  }

  if (strategy.logLevel === 'error') {
    logger.error(`${context.operation} failed`, logData)
  } else if (strategy.logLevel === 'warn') {
    logger.warn(`${context.operation} encountered an issue`, logData)
  } else {
    logger.info(`${context.operation} info`, logData)
  }
}

/**
 * Get user-friendly error message
 */
export function getUserFriendlyErrorMessage(error: unknown): string {
  const { strategy } = handleResponseError(error)
  return strategy.userMessage
}

/**
 * Determine if error is retryable
 */
export function isErrorRetryable(error: unknown): boolean {
  const { details } = handleResponseError(error)
  return details.retryable
}

/**
 * Get retry strategy for error
 */
export function getRetryStrategy(error: unknown): ErrorRecoveryStrategy {
  const { strategy } = handleResponseError(error)
  return strategy
}

/**
 * Enhanced error categorization with more granular types
 */
export interface EnhancedErrorDetails {
  code: string
  message: string
  category: 'client' | 'server' | 'network' | 'timeout' | 'validation' | 'rate_limit' | 'auth' | 'unknown'
  statusCode?: number
  retryable: boolean
  severity: 'critical' | 'high' | 'medium' | 'low'
  suggestedAction: string
  originalError?: unknown
}

/**
 * Categorize error with enhanced details
 */
export function categorizeErrorEnhanced(error: unknown): EnhancedErrorDetails {
  const message = error instanceof Error ? error.message : String(error)
  const lowerMessage = message.toLowerCase()

  let category: EnhancedErrorDetails['category'] = 'unknown'
  let statusCode: number | undefined
  let severity: EnhancedErrorDetails['severity'] = 'medium'
  let suggestedAction = 'Please try again.'
  let retryable = true

  // Rate limit errors (429)
  if (lowerMessage.includes('429') || lowerMessage.includes('rate') || lowerMessage.includes('too many requests')) {
    category = 'rate_limit'
    statusCode = 429
    severity = 'high'
    retryable = true
    suggestedAction = 'Please wait a moment before trying again. The service is experiencing high demand.'
  }
  // Authentication errors (401)
  else if (lowerMessage.includes('401') || lowerMessage.includes('unauthorized') || lowerMessage.includes('unauthenticated')) {
    category = 'auth'
    statusCode = 401
    severity = 'critical'
    retryable = false
    suggestedAction = 'Please check your API key or credentials and try again.'
  }
  // Authorization errors (403)
  else if (lowerMessage.includes('403') || lowerMessage.includes('forbidden') || lowerMessage.includes('permission denied')) {
    category = 'auth'
    statusCode = 403
    severity = 'high'
    retryable = false
    suggestedAction = 'You do not have permission to perform this action.'
  }
  // Bad request errors (400)
  else if (lowerMessage.includes('400') || lowerMessage.includes('bad request') || lowerMessage.includes('invalid request')) {
    category = 'validation'
    statusCode = 400
    severity = 'high'
    retryable = false
    suggestedAction = 'Please check your input and try again.'
  }
  // Server errors (5xx)
  else if (
    lowerMessage.includes('500') ||
    lowerMessage.includes('502') ||
    lowerMessage.includes('503') ||
    lowerMessage.includes('504') ||
    lowerMessage.includes('server error') ||
    lowerMessage.includes('internal error')
  ) {
    category = 'server'
    statusCode = 500
    severity = 'high'
    retryable = true
    suggestedAction = 'The server is experiencing issues. Please try again later.'
  }
  // Timeout errors
  else if (lowerMessage.includes('timeout') || lowerMessage.includes('timed out') || lowerMessage.includes('deadline exceeded')) {
    category = 'timeout'
    statusCode = 408
    severity = 'medium'
    retryable = true
    suggestedAction = 'The request took too long. Please try again.'
  }
  // Network errors
  else if (
    lowerMessage.includes('network') ||
    lowerMessage.includes('fetch') ||
    lowerMessage.includes('econnrefused') ||
    lowerMessage.includes('enotfound') ||
    lowerMessage.includes('econnreset') ||
    lowerMessage.includes('connection refused') ||
    lowerMessage.includes('connection reset')
  ) {
    category = 'network'
    severity = 'high'
    retryable = true
    suggestedAction = 'Please check your internet connection and try again.'
  }
  // Default unknown error
  else {
    category = 'unknown'
    severity = 'medium'
    retryable = true
    suggestedAction = 'An unexpected error occurred. Please try again.'
  }

  return {
    code: `${category.toUpperCase()}_ERROR`,
    message,
    category,
    statusCode,
    retryable,
    severity,
    suggestedAction,
    originalError: error,
  }
}

/**
 * Get recovery strategy with enhanced details
 */
export function getEnhancedRecoveryStrategy(error: unknown): {
  details: EnhancedErrorDetails
  strategy: ErrorRecoveryStrategy
} {
  const details = categorizeErrorEnhanced(error)

  const strategy: ErrorRecoveryStrategy = {
    shouldRetry: details.retryable,
    retryDelay: calculateRetryDelay(details.category),
    maxRetries: calculateMaxRetries(details.category),
    userMessage: details.suggestedAction,
    logLevel: details.severity === 'critical' ? 'error' : details.severity === 'high' ? 'error' : 'warn',
  }

  return { details, strategy }
}

/**
 * Calculate retry delay based on error category
 */
function calculateRetryDelay(category: EnhancedErrorDetails['category']): number {
  const delays: Record<EnhancedErrorDetails['category'], number> = {
    rate_limit: 5000,
    timeout: 2000,
    network: 3000,
    server: 4000,
    client: 0,
    auth: 0,
    validation: 0,
    unknown: 2000,
  }
  return delays[category] || 2000
}

/**
 * Calculate max retries based on error category
 */
function calculateMaxRetries(category: EnhancedErrorDetails['category']): number {
  const retries: Record<EnhancedErrorDetails['category'], number> = {
    rate_limit: 5,
    timeout: 3,
    network: 3,
    server: 3,
    client: 0,
    auth: 0,
    validation: 0,
    unknown: 2,
  }
  return retries[category] || 2
}



================================================================================
FILE: src/utils/formatting.ts
================================================================================
/**
 * Text and content formatting utilities
 * Provides consistent formatting across the application
 */

/**
 * Format a date to a readable time string
 * @param date - Date to format
 * @returns Formatted time string (e.g., "2:30 PM")
 */
export function formatTime(date: Date | number): string {
  const dateObj = typeof date === 'number' ? new Date(date) : date
  return dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
}

/**
 * Format a date to a readable date string
 * @param date - Date to format
 * @returns Formatted date string (e.g., "Nov 24, 2025")
 */
export function formatDate(date: Date | number): string {
  const dateObj = typeof date === 'number' ? new Date(date) : date
  return dateObj.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' })
}

/**
 * Format a date to a readable date and time string
 * @param date - Date to format
 * @returns Formatted date and time string
 */
export function formatDateTime(date: Date | number): string {
  return `${formatDate(date)} ${formatTime(date)}`
}

/**
 * Truncate text to a maximum length with ellipsis
 * @param text - Text to truncate
 * @param maxLength - Maximum length
 * @returns Truncated text
 */
export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text
  return `${text.slice(0, maxLength)}...`
}

/**
 * Capitalize the first letter of a string
 * @param text - Text to capitalize
 * @returns Capitalized text
 */
export function capitalize(text: string): string {
  if (!text) return ''
  return text.charAt(0).toUpperCase() + text.slice(1)
}

/**
 * Convert text to title case
 * @param text - Text to convert
 * @returns Title case text
 */
export function toTitleCase(text: string): string {
  return text
    .toLowerCase()
    .split(' ')
    .map(word => capitalize(word))
    .join(' ')
}

/**
 * Sanitize text for display (remove extra whitespace)
 * @param text - Text to sanitize
 * @returns Sanitized text
 */
export function sanitizeText(text: string): string {
  return text.trim().replace(/\s+/g, ' ')
}

/**
 * Format a number with thousand separators
 * @param num - Number to format
 * @returns Formatted number string
 */
export function formatNumber(num: number): string {
  return num.toLocaleString()
}

/**
 * Format bytes to human-readable size
 * @param bytes - Number of bytes
 * @returns Formatted size string (e.g., "1.5 MB")
 */
export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i]
}

/**
 * Extract first line from text
 * @param text - Text to extract from
 * @returns First line
 */
export function getFirstLine(text: string): string {
  return text.split('\n')[0]
}

/**
 * Count words in text
 * @param text - Text to count
 * @returns Word count
 */
export function countWords(text: string): number {
  return text.trim().split(/\s+/).filter(word => word.length > 0).length
}



================================================================================
FILE: src/utils/responseCache.ts
================================================================================
import { logger } from '../services/logger'
import type { CacheEntry } from '../types'

/**
 * Response Cache Manager
 * Caches API responses to reduce redundant requests
 */

export class ResponseCache<T = unknown> {
  private cache: Map<string, CacheEntry<T>> = new Map()
  private defaultTTL: number = 300000 // 5 minutes

  constructor(defaultTTL?: number) {
    if (defaultTTL) {
      this.defaultTTL = defaultTTL
    }
  }

  /**
   * Set cache entry
   */
  set(key: string, data: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      data,
      timestamp: new Date(),
      ttl,
      hits: 0,
    })
    logger.debug('Cache entry set', { key, ttl })
  }

  /**
   * Get cache entry if valid
   */
  get(key: string): T | null {
    const entry = this.cache.get(key)

    if (!entry) {
      return null
    }

    // Check if entry has expired
    const age = Date.now() - entry.timestamp.getTime()
    if (age > entry.ttl) {
      this.cache.delete(key)
      logger.debug('Cache entry expired', { key, age })
      return null
    }

    entry.hits++
    logger.debug('Cache hit', { key, hits: entry.hits })
    return entry.data
  }

  /**
   * Check if key exists and is valid
   */
  has(key: string): boolean {
    const entry = this.cache.get(key)
    if (!entry) return false

    const age = Date.now() - entry.timestamp.getTime()
    if (age > entry.ttl) {
      this.cache.delete(key)
      return false
    }

    return true
  }

  /**
   * Delete cache entry
   */
  delete(key: string): boolean {
    return this.cache.delete(key)
  }

  /**
   * Clear all cache entries
   */
  clear(): void {
    this.cache.clear()
    logger.info('Cache cleared')
  }

  /**
   * Get cache statistics
   */
  getStats(): {
    size: number
    entries: Array<{ key: string; hits: number; age: number; ttl: number }>
  } {
    const entries = Array.from(this.cache.entries()).map(([key, entry]) => ({
      key,
      hits: entry.hits,
      age: Date.now() - entry.timestamp.getTime(),
      ttl: entry.ttl,
    }))

    return {
      size: this.cache.size,
      entries,
    }
  }

  /**
   * Clean up expired entries
   */
  cleanup(): number {
    let removed = 0
    const now = Date.now()

    for (const [key, entry] of this.cache.entries()) {
      const age = now - entry.timestamp.getTime()
      if (age > entry.ttl) {
        this.cache.delete(key)
        removed++
      }
    }

    if (removed > 0) {
      logger.debug('Cache cleanup completed', { removed })
    }

    return removed
  }

  /**
   * Get cache size
   */
  size(): number {
    return this.cache.size
  }
}

/**
 * Create a cache for chat responses
 */
export function createChatResponseCache(): ResponseCache<string> {
  return new ResponseCache<string>(600000) // 10 minutes
}

/**
 * Create a cache for API responses
 */
export function createApiResponseCache<T = unknown>(): ResponseCache<T> {
  return new ResponseCache<T>(300000) // 5 minutes
}



================================================================================
FILE: src/utils/responseFormatter.ts
================================================================================
import { logger } from '../services/logger'
import { API } from '../constants'
import type {
  ApiResponse,
  ErrorDetails,
  FormattedChatResponse,
  ValidationResult,
  ResponseMetadata,
  ResponseFormattingOptions,
  StreamingChunk,
  EnhancedApiResponse,
} from '../types'

/**
 * Response Formatter Utility
 * Handles formatting, validation, and normalization of API responses
 */

const DEFAULT_FORMATTING_OPTIONS: ResponseFormattingOptions = {
  sanitize: true,
  validateSchema: true,
  includeMetadata: true,
  formatMarkdown: true,
  maxLength: 10000,
  timeout: API.REQUEST_TIMEOUT_MS,
}

/**
 * Sanitize response content by removing potentially harmful content
 */
export function sanitizeContent(content: string): string {
  if (!content || typeof content !== 'string') {
    return ''
  }

  // Remove null bytes and control characters
  // eslint-disable-next-line no-control-regex
  let sanitized = content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')

  // Trim excessive whitespace
  sanitized = sanitized.replace(/\s+/g, ' ').trim()

  return sanitized
}

/**
 * Validate response content
 */
export function validateResponse(content: unknown): ValidationResult {
  const errors: string[] = []
  const warnings: string[] = []
  let sanitized = false

  if (!content) {
    errors.push('Response content is empty or null')
    return { isValid: false, errors, warnings, sanitized }
  }

  if (typeof content !== 'string') {
    errors.push(`Expected string content, got ${typeof content}`)
    return { isValid: false, errors, warnings, sanitized }
  }

  if (content.trim().length === 0) {
    errors.push('Response content is empty after trimming')
    return { isValid: false, errors, warnings, sanitized }
  }

  if (content.length > DEFAULT_FORMATTING_OPTIONS.maxLength!) {
    warnings.push(`Content exceeds max length of ${DEFAULT_FORMATTING_OPTIONS.maxLength}`)
  }

  // Check for suspicious patterns
  if (content.includes('\x00')) {
    warnings.push('Content contains null bytes')
    sanitized = true
  }

  return { isValid: true, errors, warnings, sanitized }
}

/**
 * Detect content type
 */
export function detectContentType(content: string): 'text' | 'markdown' | 'json' | 'mixed' {
  if (content.startsWith('{') || content.startsWith('[')) {
    try {
      JSON.parse(content)
      return 'json'
    } catch {
      // Not valid JSON
    }
  }

  if (content.includes('```') || content.includes('**') || content.includes('##')) {
    return 'markdown'
  }

  return 'text'
}

/**
 * Create response metadata
 */
export function createMetadata(
  provider: string,
  duration: number,
  retryCount: number = 0,
  model?: string,
  tokensUsed?: { prompt: number; completion: number; total: number }
): ResponseMetadata {
  return {
    timestamp: new Date(),
    duration,
    retryCount,
    provider,
    model,
    tokensUsed,
  }
}

/**
 * Format chat response with validation and sanitization
 */
export function formatChatResponse(
  content: string,
  metadata: Partial<ResponseMetadata>,
  options: Partial<ResponseFormattingOptions> = {}
): FormattedChatResponse {
  const opts = { ...DEFAULT_FORMATTING_OPTIONS, ...options }

  // Validate
  const validation = validateResponse(content)
  if (!validation.isValid) {
    logger.warn('Response validation failed', { errors: validation.errors })
  }

  // Sanitize
  const sanitized = opts.sanitize ? sanitizeContent(content) : content
  const contentType = detectContentType(sanitized)

  return {
    content: sanitized,
    contentType,
    length: sanitized.length,
    hasFormatting: contentType !== 'text',
    sanitized: opts.sanitize && validation.sanitized,
    metadata: {
      model: metadata.model || 'unknown',
      temperature: 0.7,
      maxTokens: 1000,
      finishReason: 'stop',
    },
  }
}

/**
 * Create success response envelope
 */
export function createSuccessResponse<T>(
  data: T,
  metadata: ResponseMetadata
): ApiResponse<T> {
  return {
    success: true,
    data,
    metadata,
  }
}

/**
 * Create error response envelope
 */
export function createErrorResponse(
  error: unknown,
  metadata: ResponseMetadata
): ApiResponse<null> {
  const errorDetails = parseError(error)
  return {
    success: false,
    error: errorDetails,
    metadata,
  }
}

/**
 * Parse and categorize errors with comprehensive error detection
 */
export function parseError(error: unknown): ErrorDetails {
  const message = error instanceof Error ? error.message : String(error)
  const lowerMessage = message.toLowerCase()

  let category: ErrorDetails['category'] = 'unknown'
  let statusCode: number | undefined
  let retryable = true

  // Authentication errors (401)
  if (lowerMessage.includes('401') || lowerMessage.includes('unauthorized') || lowerMessage.includes('unauthenticated')) {
    category = 'client'
    statusCode = 401
    retryable = false
  }
  // Authorization errors (403)
  else if (lowerMessage.includes('403') || lowerMessage.includes('forbidden') || lowerMessage.includes('permission denied')) {
    category = 'client'
    statusCode = 403
    retryable = false
  }
  // Bad request errors (400)
  else if (lowerMessage.includes('400') || lowerMessage.includes('bad request') || lowerMessage.includes('invalid request')) {
    category = 'validation'
    statusCode = 400
    retryable = false
  }
  // Rate limit errors (429)
  else if (lowerMessage.includes('429') || lowerMessage.includes('rate') || lowerMessage.includes('too many requests')) {
    category = 'client'
    statusCode = 429
    retryable = true
  }
  // Server errors (5xx)
  else if (
    lowerMessage.includes('500') ||
    lowerMessage.includes('502') ||
    lowerMessage.includes('503') ||
    lowerMessage.includes('504') ||
    lowerMessage.includes('server error') ||
    lowerMessage.includes('internal error')
  ) {
    category = 'server'
    statusCode = 500
    retryable = true
  }
  // Timeout errors
  else if (lowerMessage.includes('timeout') || lowerMessage.includes('timed out') || lowerMessage.includes('deadline exceeded')) {
    category = 'timeout'
    statusCode = 408
    retryable = true
  }
  // Network errors
  else if (
    lowerMessage.includes('network') ||
    lowerMessage.includes('fetch') ||
    lowerMessage.includes('econnrefused') ||
    lowerMessage.includes('enotfound') ||
    lowerMessage.includes('econnreset') ||
    lowerMessage.includes('connection refused')
  ) {
    category = 'network'
    retryable = true
  }

  return {
    code: `${category.toUpperCase()}_ERROR`,
    message,
    category,
    statusCode,
    retryable,
    originalError: error,
  }
}

/**
 * Handle null, undefined, and empty responses
 */
export function handleNullOrUndefinedResponse(value: unknown): string {
  if (value === null) {
    logger.warn('Response is null')
    return ''
  }
  if (value === undefined) {
    logger.warn('Response is undefined')
    return ''
  }
  if (typeof value === 'string') {
    return value
  }
  if (typeof value === 'object') {
    try {
      return JSON.stringify(value)
    } catch (error) {
      logger.error('Failed to stringify object response', error)
      return String(value)
    }
  }
  return String(value)
}

/**
 * Handle partial or incomplete responses
 */
export function handlePartialResponse(content: string, isComplete: boolean): { content: string; isPartial: boolean } {
  if (!isComplete && content.trim().length > 0) {
    logger.warn('Received partial response', { contentLength: content.length })
    return { content, isPartial: true }
  }
  return { content, isPartial: false }
}

/**
 * Validate and parse JSON responses safely
 */
export function safeJsonParse<T = unknown>(jsonString: string): { success: boolean; data?: T; error?: string } {
  try {
    const data = JSON.parse(jsonString) as T
    return { success: true, data }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown JSON parse error'
    logger.error('JSON parse error', { error: errorMessage, input: jsonString.substring(0, 100) })
    return { success: false, error: errorMessage }
  }
}

/**
 * Handle streaming responses
 */
export function createStreamingChunk(
  id: string,
  content: string,
  isComplete: boolean,
  error?: ErrorDetails
): StreamingChunk {
  return {
    id,
    timestamp: new Date(),
    content,
    isComplete,
    error,
  }
}

/**
 * Accumulate streaming chunks into complete response
 */
export function accumulateStreamingChunks(chunks: StreamingChunk[]): string {
  return chunks.map((chunk) => chunk.content).join('')
}

/**
 * Validate response structure against expected schema
 */
export function validateResponseStructure(
  response: unknown,
  expectedFields: string[]
): { isValid: boolean; missingFields: string[] } {
  if (typeof response !== 'object' || response === null) {
    return { isValid: false, missingFields: expectedFields }
  }

  const responseObj = response as Record<string, unknown>
  const missingFields = expectedFields.filter((field) => !(field in responseObj))

  return {
    isValid: missingFields.length === 0,
    missingFields,
  }
}

/**
 * Normalize response format across different API providers
 */
export function normalizeResponse(response: unknown): { content: string; metadata: Record<string, unknown> } {
  const metadata: Record<string, unknown> = {}

  // Handle string responses
  if (typeof response === 'string') {
    return { content: response, metadata }
  }

  // Handle object responses
  if (typeof response === 'object' && response !== null) {
    const obj = response as Record<string, unknown>

    // Try common content field names
    const contentField = ['content', 'text', 'message', 'data', 'result', 'output'].find((field) => field in obj)
    const content = contentField ? String(obj[contentField]) : JSON.stringify(obj)

    // Extract metadata
    Object.entries(obj).forEach(([key, value]) => {
      if (key !== contentField && typeof value !== 'function') {
        metadata[key] = value
      }
    })

    return { content, metadata }
  }

  // Fallback
  return { content: String(response), metadata }
}

/**
 * Create enhanced API response with additional context
 */
export function createEnhancedResponse<T>(
  data: T,
  metadata: ResponseMetadata,
  options?: {
    cached?: boolean
    streaming?: boolean
    partial?: boolean
    retryInfo?: { attempt: number; maxAttempts: number; nextRetryTime?: Date }
  }
): EnhancedApiResponse<T> {
  return {
    success: true,
    data,
    metadata,
    cached: options?.cached,
    streaming: options?.streaming,
    partial: options?.partial,
    retryInfo: options?.retryInfo,
  }
}

/**
 * Detect if response is HTML (error page) instead of expected format
 */
export function isHtmlResponse(content: string): boolean {
  const trimmed = content.trim()
  return trimmed.startsWith('<') && (trimmed.includes('<!DOCTYPE') || trimmed.includes('<html') || trimmed.includes('<body'))
}

/**
 * Extract error message from HTML error page
 */
export function extractErrorFromHtml(htmlContent: string): string {
  try {
    // Try to extract from common error page patterns
    const titleMatch = htmlContent.match(/<title[^>]*>([^<]+)<\/title>/i)
    if (titleMatch) {
      return titleMatch[1]
    }

    const h1Match = htmlContent.match(/<h1[^>]*>([^<]+)<\/h1>/i)
    if (h1Match) {
      return h1Match[1]
    }

    const bodyMatch = htmlContent.match(/<body[^>]*>([\s\S]*?)<\/body>/i)
    if (bodyMatch) {
      const text = bodyMatch[1].replace(/<[^>]+>/g, '').trim()
      return text.substring(0, 200)
    }

    return 'Received HTML error page from server'
  } catch (error) {
    logger.error('Error extracting error from HTML', error)
    return 'Unknown error from server'
  }
}



================================================================================
FILE: src/utils/responseValidator.ts
================================================================================
import { logger } from '../services/logger'

/**
 * Response Validation Schema
 * Validates responses against expected schemas
 */

export interface ValidationSchema {
  type: 'string' | 'number' | 'boolean' | 'object' | 'array'
  required?: boolean
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  properties?: Record<string, ValidationSchema>
  items?: ValidationSchema
  enum?: unknown[]
}

export interface ValidationError {
  path: string
  message: string
  value?: unknown
}

/**
 * Validate value against schema
 */
export function validateAgainstSchema(
  value: unknown,
  schema: ValidationSchema,
  path: string = 'root'
): { valid: boolean; errors: ValidationError[] } {
  const errors: ValidationError[] = []

  // Check type
  const actualType = Array.isArray(value) ? 'array' : typeof value
  if (actualType !== schema.type) {
    errors.push({
      path,
      message: `Expected type ${schema.type}, got ${actualType}`,
      value,
    })
    return { valid: false, errors }
  }

  // Check required
  if (schema.required && (value === null || value === undefined)) {
    errors.push({
      path,
      message: 'Value is required',
      value,
    })
    return { valid: false, errors }
  }

  // String validations
  if (schema.type === 'string' && typeof value === 'string') {
    if (schema.minLength !== undefined && value.length < schema.minLength) {
      errors.push({
        path,
        message: `String length ${value.length} is less than minimum ${schema.minLength}`,
        value,
      })
    }
    if (schema.maxLength !== undefined && value.length > schema.maxLength) {
      errors.push({
        path,
        message: `String length ${value.length} exceeds maximum ${schema.maxLength}`,
        value,
      })
    }
    if (schema.pattern && !schema.pattern.test(value)) {
      errors.push({
        path,
        message: `String does not match pattern ${schema.pattern}`,
        value,
      })
    }
  }

  // Enum validation
  if (schema.enum && !schema.enum.includes(value)) {
    errors.push({
      path,
      message: `Value must be one of: ${schema.enum.join(', ')}`,
      value,
    })
  }

  // Object validations
  if (schema.type === 'object' && typeof value === 'object' && value !== null) {
    const obj = value as Record<string, unknown>
    if (schema.properties) {
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        const propValue = obj[key]
        const propPath = `${path}.${key}`
        const result = validateAgainstSchema(propValue, propSchema, propPath)
        errors.push(...result.errors)
      }
    }
  }

  // Array validations
  if (schema.type === 'array' && Array.isArray(value)) {
    if (schema.items) {
      for (let i = 0; i < value.length; i++) {
        const itemPath = `${path}[${i}]`
        const result = validateAgainstSchema(value[i], schema.items, itemPath)
        errors.push(...result.errors)
      }
    }
  }

  return { valid: errors.length === 0, errors }
}

/**
 * Create schema for OpenAI chat response
 */
export function createOpenAIResponseSchema(): ValidationSchema {
  return {
    type: 'object',
    required: true,
    properties: {
      id: { type: 'string', required: true },
      object: { type: 'string', required: true, enum: ['chat.completion'] },
      created: { type: 'number', required: true },
      model: { type: 'string', required: true },
      choices: {
        type: 'array',
        required: true,
        items: {
          type: 'object',
          properties: {
            index: { type: 'number' },
            message: {
              type: 'object',
              properties: {
                role: { type: 'string', enum: ['assistant'] },
                content: { type: 'string', required: true },
              },
            },
            finish_reason: { type: 'string' },
          },
        },
      },
      usage: {
        type: 'object',
        properties: {
          prompt_tokens: { type: 'number' },
          completion_tokens: { type: 'number' },
          total_tokens: { type: 'number' },
        },
      },
    },
  }
}

/**
 * Create schema for generic chat response
 */
export function createGenericChatResponseSchema(): ValidationSchema {
  return {
    type: 'object',
    required: true,
    properties: {
      content: { type: 'string', required: true, minLength: 1 },
      model: { type: 'string' },
      tokensUsed: {
        type: 'object',
        properties: {
          prompt: { type: 'number' },
          completion: { type: 'number' },
          total: { type: 'number' },
        },
      },
    },
  }
}

/**
 * Log validation errors
 */
export function logValidationErrors(errors: ValidationError[], context: string): void {
  if (errors.length === 0) return

  logger.error(`Validation errors in ${context}`, {
    errorCount: errors.length,
    errors: errors.map((e) => ({
      path: e.path,
      message: e.message,
    })),
  })
}



================================================================================
FILE: src/utils/retry.ts
================================================================================
import { logger } from '../services/logger'
import { isErrorRetryable } from './errorHandler'

interface RetryOptions {
  maxAttempts?: number
  delayMs?: number
  backoffMultiplier?: number
}

const DEFAULT_OPTIONS: Required<RetryOptions> = {
  maxAttempts: 3,
  delayMs: 1000,
  backoffMultiplier: 2,
}

/**
 * Retry a function with exponential backoff
 * @param fn - The async function to retry
 * @param options - Retry configuration options
 * @returns The result of the function
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const config = { ...DEFAULT_OPTIONS, ...options }
  let lastError: Error | null = null

  for (let attempt = 1; attempt <= config.maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error))

      // Check if error is retryable using enhanced error handler
      if (!isErrorRetryable(error)) {
        logger.debug('Error is not retryable, throwing immediately', { error: lastError.message })
        throw error
      }

      if (attempt < config.maxAttempts) {
        const delay = config.delayMs * Math.pow(config.backoffMultiplier, attempt - 1)
        logger.debug(`Retry attempt ${attempt}/${config.maxAttempts} after ${delay}ms`, {
          error: lastError.message,
          nextDelay: delay,
        })
        await new Promise((resolve) => setTimeout(resolve, delay))
      }
    }
  }

  logger.error(`Failed after ${config.maxAttempts} attempts`, { error: lastError?.message })
  throw lastError
}



================================================================================
FILE: src/utils/streamingResponseHandler.ts
================================================================================
import { logger } from '../services/logger'
import { API } from '../constants'
import type { StreamingOptions, ErrorDetails } from '../types'
import { createStreamingChunk } from './responseFormatter'

/**
 * Streaming Response Handler
 * Handles Server-Sent Events (SSE) and chunked streaming responses
 */

/**
 * Handle Server-Sent Events (SSE) streaming
 */
export async function handleSSEStream(
  response: Response,
  options: StreamingOptions = {}
): Promise<string> {
  const reader = response.body?.getReader()
  if (!reader) {
    throw new Error('Response body is not readable')
  }

  const decoder = new TextDecoder()
  let fullContent = ''
  let chunkCount = 0
  const maxChunks = options.maxChunks || 1000
  const timeout = options.timeout || API.REQUEST_TIMEOUT_MS
  const startTime = Date.now()

  try {
    while (true) {
      if (Date.now() - startTime > timeout) {
        throw new Error('Streaming response timeout')
      }

      if (chunkCount >= maxChunks) {
        logger.warn('Max chunks reached', { maxChunks })
        break
      }

      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value, { stream: true })
      fullContent += chunk
      chunkCount++

      // Parse SSE format (data: ...)
      const lines = chunk.split('\n')
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6)
          if (data === '[DONE]') {
            const streamChunk = createStreamingChunk(
              `chunk-${chunkCount}`,
              fullContent,
              true
            )
            options.onChunk?.(streamChunk)
            options.onComplete?.(fullContent)
            return fullContent
          }

          const streamChunk = createStreamingChunk(
            `chunk-${chunkCount}`,
            data,
            false
          )
          options.onChunk?.(streamChunk)
        }
      }
    }

    options.onComplete?.(fullContent)
    return fullContent
  } catch (error) {
    const errorDetails: ErrorDetails = {
      code: 'STREAMING_ERROR',
      message: error instanceof Error ? error.message : 'Unknown streaming error',
      category: 'network',
      retryable: true,
      originalError: error,
    }
    options.onError?.(errorDetails)
    throw error
  } finally {
    reader.cancel()
  }
}

/**
 * Handle chunked transfer encoding
 */
export async function handleChunkedResponse(
  response: Response,
  options: StreamingOptions = {}
): Promise<string> {
  const reader = response.body?.getReader()
  if (!reader) {
    throw new Error('Response body is not readable')
  }

  const decoder = new TextDecoder()
  let fullContent = ''
  let chunkCount = 0
  const maxChunks = options.maxChunks || 1000
  const timeout = options.timeout || API.REQUEST_TIMEOUT_MS
  const startTime = Date.now()

  try {
    while (true) {
      if (Date.now() - startTime > timeout) {
        throw new Error('Chunked response timeout')
      }

      if (chunkCount >= maxChunks) {
        logger.warn('Max chunks reached', { maxChunks })
        break
      }

      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value, { stream: true })
      fullContent += chunk
      chunkCount++

      const streamChunk = createStreamingChunk(
        `chunk-${chunkCount}`,
        chunk,
        false
      )
      options.onChunk?.(streamChunk)
    }

    const finalChunk = createStreamingChunk(
      `chunk-${chunkCount}`,
      fullContent,
      true
    )
    options.onChunk?.(finalChunk)
    options.onComplete?.(fullContent)
    return fullContent
  } catch (error) {
    const errorDetails: ErrorDetails = {
      code: 'CHUNKED_RESPONSE_ERROR',
      message: error instanceof Error ? error.message : 'Unknown chunked response error',
      category: 'network',
      retryable: true,
      originalError: error,
    }
    options.onError?.(errorDetails)
    throw error
  } finally {
    reader.cancel()
  }
}

/**
 * Detect streaming response type
 */
export function detectStreamingType(response: Response): 'sse' | 'chunked' | 'none' {
  const contentType = response.headers.get('content-type') || ''
  const transferEncoding = response.headers.get('transfer-encoding') || ''

  if (contentType.includes('text/event-stream')) {
    return 'sse'
  }

  if (transferEncoding.includes('chunked')) {
    return 'chunked'
  }

  return 'none'
}



================================================================================
FILE: src/utils/timestampConverter.ts
================================================================================
/**
 * Timestamp conversion utilities for Firestore integration
 * Safely converts Firestore Timestamps to JavaScript Dates with proper fallbacks
 */

import { Timestamp } from 'firebase/firestore'
import { logger } from '../services/logger'

/**
 * Safely convert a Firestore Timestamp, Date, string, or undefined to a valid Date
 * @param value - The value to convert (Timestamp, Date, string, or undefined)
 * @param fieldName - Optional field name for logging context
 * @returns A valid Date object or current date as fallback
 */
export function toDate(value: unknown, fieldName?: string): Date {
  // Handle Firestore Timestamp
  if (value instanceof Timestamp) {
    return value.toDate()
  }

  // Handle JavaScript Date
  if (value instanceof Date) {
    return value
  }

  // Handle ISO string
  if (typeof value === 'string') {
    try {
      const date = new Date(value)
      if (!isNaN(date.getTime())) {
        return date
      }
    } catch (error) {
      logger.warn(`Failed to parse date string: ${value}`, { fieldName, error })
    }
  }

  // Handle number (milliseconds since epoch)
  if (typeof value === 'number') {
    const date = new Date(value)
    if (!isNaN(date.getTime())) {
      return date
    }
  }

  // Fallback: log warning and return current date
  if (value !== undefined && value !== null) {
    logger.warn(`Invalid timestamp value, using current date as fallback`, {
      fieldName,
      valueType: typeof value,
      value: String(value).substring(0, 50),
    })
  }

  return new Date()
}

/**
 * Safely convert a Firestore Timestamp to a Date, with optional default
 * @param value - The Firestore Timestamp to convert
 * @param defaultDate - Optional default date if conversion fails
 * @returns A valid Date object
 */
export function timestampToDate(value: Timestamp | undefined, defaultDate?: Date): Date {
  if (!value) {
    return defaultDate || new Date()
  }

  try {
    return value.toDate()
  } catch (error) {
    logger.warn('Failed to convert Firestore Timestamp to Date', { error })
    return defaultDate || new Date()
  }
}

/**
 * Validate that a date is reasonable (not too far in past or future)
 * @param date - The date to validate
 * @param maxAgeMs - Maximum age in milliseconds (default: 100 years)
 * @param maxFutureMs - Maximum future time in milliseconds (default: 1 year)
 * @returns true if date is reasonable, false otherwise
 */
export function isReasonableDate(
  date: Date,
  maxAgeMs: number = 100 * 365 * 24 * 60 * 60 * 1000,
  maxFutureMs: number = 365 * 24 * 60 * 60 * 1000
): boolean {
  const now = Date.now()
  const dateTime = date.getTime()

  return dateTime >= now - maxAgeMs && dateTime <= now + maxFutureMs
}



================================================================================
FILE: src/utils/titleGenerator.ts
================================================================================
/**
 * Utility functions for generating conversation titles
 */

/**
 * Generate a concise title from the first user message
 * Uses the first sentence or first ~60 characters
 * @param message - The first user message
 * @returns A concise title
 */
export function generateTitleFromMessage(message: string): string {
  if (!message || message.trim().length === 0) {
    return `Chat ${new Date().toLocaleDateString()}`
  }

  // Remove extra whitespace
  const cleaned = message.trim()

  // Try to find the first sentence (ends with . ! or ?)
  const sentenceMatch = cleaned.match(/^[^.!?]*[.!?]/)
  if (sentenceMatch) {
    const sentence = sentenceMatch[0].trim()
    if (sentence.length <= 100) {
      return sentence
    }
  }

  // Fall back to first ~60 characters
  const truncated = cleaned.substring(0, 60).trim()
  if (truncated.length < cleaned.length) {
    return truncated + '...'
  }

  return truncated
}

/**
 * Generate a default title with current date
 * @returns A default title
 */
export function generateDefaultTitle(): string {
  return `Chat ${new Date().toLocaleDateString()}`
}



================================================================================
FILE: src/utils/validation.ts
================================================================================
/**
 * Input validation utilities
 * Provides consistent validation across the application
 */

/**
 * Check if a string is empty or whitespace only
 * @param text - Text to check
 * @returns true if empty or whitespace only
 */
export function isEmpty(text: string): boolean {
  return !text || text.trim().length === 0
}

/**
 * Check if a string is not empty
 * @param text - Text to check
 * @returns true if not empty
 */
export function isNotEmpty(text: string): boolean {
  return !isEmpty(text)
}

/**
 * Validate email format
 * @param email - Email to validate
 * @returns true if valid email format
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

/**
 * Validate URL format
 * @param url - URL to validate
 * @returns true if valid URL format
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

/**
 * Check if a string is a valid UUID
 * @param uuid - UUID to validate
 * @returns true if valid UUID
 */
export function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  return uuidRegex.test(uuid)
}

/**
 * Validate message content
 * @param message - Message to validate
 * @param maxLength - Maximum allowed length
 * @returns Validation result with errors
 */
export function validateMessage(message: string, maxLength: number = 4000): { isValid: boolean; errors: string[] } {
  const errors: string[] = []

  if (isEmpty(message)) {
    errors.push('Message cannot be empty')
  }

  if (message.length > maxLength) {
    errors.push(`Message cannot exceed ${maxLength} characters`)
  }

  return {
    isValid: errors.length === 0,
    errors,
  }
}

/**
 * Validate conversation title
 * @param title - Title to validate
 * @returns Validation result with errors
 */
export function validateConversationTitle(title: string): { isValid: boolean; errors: string[] } {
  const errors: string[] = []

  if (isEmpty(title)) {
    errors.push('Title cannot be empty')
  }

  if (title.length > 100) {
    errors.push('Title cannot exceed 100 characters')
  }

  return {
    isValid: errors.length === 0,
    errors,
  }
}

/**
 * Check if a value is null or undefined
 * @param value - Value to check
 * @returns true if null or undefined
 */
export function isNullOrUndefined(value: unknown): value is null | undefined {
  return value === null || value === undefined
}

/**
 * Check if a value is defined
 * @param value - Value to check
 * @returns true if not null or undefined
 */
export function isDefined<T>(value: T | null | undefined): value is T {
  return !isNullOrUndefined(value)
}

/**
 * Check if an object is empty
 * @param obj - Object to check
 * @returns true if object has no keys
 */
export function isEmptyObject(obj: Record<string, unknown>): boolean {
  return Object.keys(obj).length === 0
}

/**
 * Check if an array is empty
 * @param arr - Array to check
 * @returns true if array is empty
 */
export function isEmptyArray<T>(arr: T[]): boolean {
  return arr.length === 0
}

/**
 * Check if an array has items
 * @param arr - Array to check
 * @returns true if array has items
 */
export function hasItems<T>(arr: T[]): boolean {
  return arr.length > 0
}



================================================================================
FILE: src/index.css
================================================================================
@import "tailwindcss";

@layer base {
  /* Typography System */
  html {
    scroll-behavior: auto;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    letter-spacing: 0.3px;
  }

  body {
    @apply bg-white text-slate-900;
  }

  /* Heading Hierarchy */
  h1 {
    @apply text-4xl font-bold tracking-tight leading-tight;
  }

  h2 {
    @apply text-3xl font-bold tracking-tight leading-snug;
  }

  h3 {
    @apply text-2xl font-semibold tracking-tight leading-snug;
  }

  h4 {
    @apply text-xl font-semibold leading-snug;
  }

  h5 {
    @apply text-lg font-semibold leading-normal;
  }

  h6 {
    @apply text-base font-semibold leading-normal;
  }

  /* Paragraph Styles */
  p {
    @apply leading-relaxed;
  }

  /* Link Styles */
  a {
    @apply text-blue-600 hover:text-blue-700 transition-colors duration-200;
  }

  /* Code Styles */
  code {
    @apply bg-slate-100 px-2 py-1 rounded text-sm font-mono text-slate-900;
  }

  pre {
    @apply bg-slate-900 text-slate-100 p-4 rounded-lg overflow-x-auto;
  }

  /* Light theme only - no dark mode support */
}

@layer utilities {
  /* Fade In Animation - used in messages and empty states */
  @keyframes fade-in {
    from {
      opacity: 0;
      transform: translateY(8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Fade In Up Animation - used in landing page features */
  @keyframes fade-in-up {
    from {
      opacity: 0;
      transform: translateY(16px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Slide In From Left - for sidebar animations */
  @keyframes slide-in-left {
    from {
      opacity: 0;
      transform: translateX(-16px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Slide In From Right - for message animations */
  @keyframes slide-in-right {
    from {
      opacity: 0;
      transform: translateX(16px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Slide In From Top - for error banners */
  @keyframes slide-in-down {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Blob Animation - used in landing page background */
  @keyframes blob {
    0%, 100% {
      transform: translate(0, 0) scale(1);
    }
    33% {
      transform: translate(30px, -50px) scale(1.1);
    }
    66% {
      transform: translate(-20px, 20px) scale(0.9);
    }
  }

  /* Pulse Animation - for loading states */
  @keyframes pulse-soft {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.6;
    }
  }

  /* Smooth scale animation */
  @keyframes scale-in {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  /* Thinking Dots Animation - Modern ellipsis effect */
  @keyframes thinking-dots {
    0%, 20% {
      content: '.';
    }
    40% {
      content: '..';
    }
    60%, 100% {
      content: '...';
    }
  }

  .animate-thinking-dots {
    animation: thinking-dots 1.4s infinite;
  }

  /* Wave Dot Animation - Sleek loading effect */
  @keyframes wave-dot {
    0%, 60%, 100% {
      transform: translateY(0);
      opacity: 0.6;
    }
    30% {
      transform: translateY(-8px);
      opacity: 1;
    }
  }

  .animate-wave-dot {
    animation: wave-dot 1.2s ease-in-out infinite;
  }

  /* Utility Classes */
  .animate-fade-in {
    animation: fade-in 0.3s ease-out forwards;
  }

  .animate-fade-in-up {
    animation: fade-in-up 0.5s ease-out forwards;
  }

  .animate-slide-in-left {
    animation: slide-in-left 0.3s ease-out forwards;
  }

  .animate-slide-in-right {
    animation: slide-in-right 0.3s ease-out forwards;
  }

  .animate-slide-in-down {
    animation: slide-in-down 0.3s ease-out forwards;
  }

  .animate-blob {
    animation: blob 7s infinite;
  }

  .animate-pulse-soft {
    animation: pulse-soft 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .animate-scale-in {
    animation: scale-in 0.3s ease-out forwards;
  }

  .animation-delay-2000 {
    animation-delay: 2s;
  }

  .delay-100 {
    animation-delay: 100ms;
  }

  .delay-200 {
    animation-delay: 200ms;
  }

  .delay-300 {
    animation-delay: 300ms;
  }

  /* Focus ring utilities for accessibility */
  .focus-ring {
    @apply focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-white;
  }

  .focus-visible-ring {
    @apply focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-white;
  }

  /* Smooth transitions for interactive elements */
  .transition-smooth {
    @apply transition-all duration-200 ease-out;
  }

  /* Gradient text utility */
  .gradient-text {
    @apply bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-400 bg-clip-text text-transparent;
  }

  /* Enhanced button transitions */
  button {
    @apply transition-all duration-200 ease-out;
  }

  /* Smooth input transitions */
  input, textarea {
    @apply transition-all duration-200 ease-out;
  }

  /* Smooth link transitions */
  a {
    @apply transition-all duration-200 ease-out;
  }

  /* Smooth scroll for specific containers only (performance optimization) */
  .smooth-scroll {
    scroll-behavior: smooth;
  }

  /* Improved button hover states */
  button:not(:disabled) {
    @apply hover:brightness-105 active:brightness-95;
  }

  /* Better input focus states */
  input:focus, textarea:focus {
    @apply ring-2 ring-blue-500 ring-offset-2 ring-offset-white;
  }

  /* Smooth scrollbar styling for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    @apply bg-slate-100;
  }

  ::-webkit-scrollbar-thumb {
    @apply bg-slate-300 rounded-full hover:bg-slate-400;
  }

  /* Selection styling */
  ::selection {
    @apply bg-blue-500 text-white;
  }

  /* Enhanced focus-visible for keyboard navigation */
  *:focus-visible {
    @apply outline-none ring-2 ring-blue-500 ring-offset-2 ring-offset-white;
  }

  /* Smooth transitions for all interactive elements */
  button, a, input, textarea, select {
    @apply transition-all duration-200 ease-out;
  }

  /* Light theme scrollbar styling only */

  /* Reduced motion support for accessibility */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Touch target sizing for mobile */
  .touch-target {
    @apply min-h-11 min-w-11;
  }

  @media (min-width: 640px) {
    .touch-target {
      @apply min-h-10 min-w-10;
    }
  }

  /* Semantic color utilities */
  .text-success {
    @apply text-green-600;
  }

  .text-warning {
    @apply text-amber-600;
  }

  .text-error {
    @apply text-red-600;
  }

  .bg-success-light {
    @apply bg-green-50;
  }

  .bg-warning-light {
    @apply bg-amber-50;
  }

  .bg-error-light {
    @apply bg-red-50;
  }

  /* Truncate with ellipsis */
  .truncate-2 {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .truncate-3 {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  /* Glassmorphism utilities */
  .glass {
    @apply bg-white/10 backdrop-blur-md border border-white/20;
  }

  /* Enhanced hover animations */
  .hover-lift {
    @apply transition-all duration-300 hover:-translate-y-1 hover:shadow-lg;
  }

  .hover-glow {
    @apply transition-all duration-300 hover:shadow-lg hover:shadow-cyan-500/30;
  }

  /* Smooth fade animations */
  @keyframes fade-in-slow {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  .animate-fade-in-slow {
    animation: fade-in-slow 0.8s ease-out forwards;
  }

  /* Stagger animation delays for landing page */
  .stagger-1 {
    animation-delay: 100ms;
  }

  .stagger-2 {
    animation-delay: 200ms;
  }

  .stagger-3 {
    animation-delay: 300ms;
  }

  .stagger-4 {
    animation-delay: 400ms;
  }

  /* Smooth scale on hover */
  .hover-scale-sm {
    @apply transition-transform duration-300 hover:scale-105;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }
}


================================================================================
FILE: vite.config.ts
================================================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
  plugins: [tailwindcss(), react()],
  resolve: {
    alias: {
      // Path alias for cleaner imports: @/components instead of ../../../components
      '@': path.resolve(__dirname, './src'),
    },
  },
  build: {
    // Optimize chunk size and code splitting for better performance
    rollupOptions: {
      output: {
        manualChunks: {
          // Separate vendor chunks to leverage browser caching
          // React ecosystem - frequently updated but stable API
          'vendor-react': ['react', 'react-dom', 'react-router-dom'],
          // Firebase - large library, good to isolate
          'vendor-firebase': ['firebase'],
          // OpenAI - external API client, stable
          'vendor-openai': ['openai'],
          // Icons - large icon library, good to isolate
          'vendor-icons': ['react-icons'],
        },
      },
    },
    // Increase chunk size warning limit since we have large dependencies
    // Firebase and OpenAI are particularly large
    chunkSizeWarningLimit: 600,
  },
})


================================================================================
FILE: tsconfig.json
================================================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================================================
FILE: tsconfig.app.json
================================================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


================================================================================
FILE: tsconfig.node.json
================================================================================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


================================================================================
FILE: eslint.config.js
================================================================================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


================================================================================
FILE: package.json
================================================================================
{
  "name": "cna-voice-notes-ai",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "firebase": "^12.6.0",
    "openai": "^6.9.1",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.9.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/vite": "^4.1.17",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.17",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


================================================================================
FILE: firebase.json
================================================================================
{
  "hosting": {
    "public": "dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(js|css|woff|woff2|eot|ttf|otf|svg)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      },
      {
        "source": "/index.html",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=0, must-revalidate"
          }
        ]
      }
    ]
  }
}



================================================================================
FILE: index.html
================================================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Marlamade</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


